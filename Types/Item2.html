<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title># 条目2：使用类型系统来表达常见行为 - effective-rust-cn</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Cover.html"><strong aria-hidden="true">1.</strong> 封面</a></li><li class="chapter-item expanded "><a href="../Introduction.html"><strong aria-hidden="true">2.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="../Types.html"><strong aria-hidden="true">3.</strong> 类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Types/Item1.html"><strong aria-hidden="true">3.1.</strong> 条目 1: 使用类型系统表达你的数据结构</a></li><li class="chapter-item expanded "><a href="../Types/Item2.html" class="active"><strong aria-hidden="true">3.2.</strong> # 条目2：使用类型系统来表达常见行为</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">effective-rust-cn</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="条目2使用类型系统来表达常见行为"><a class="header" href="#条目2使用类型系统来表达常见行为">条目2：使用类型系统来表达常见行为</a></h1>
<p>Item 1 讨论了如何使用在类型系统中表达数据结构；本项目将讨论如何使用类型系统来表达常见行为。</p>
<h1 id="方法methods"><a class="header" href="#方法methods">方法（Methods）</a></h1>
<p>首先，Rust类型系统的第一个行为就是向数据结构中添加方法：这些方法作用于某个类型的成员，由 self 标识。这种方式将相关数据和代码以面向对象的方式封装在一起，与其他语言类似；然而，在 Rust 中，方法不仅可以添加到结构类型，还可以添加到枚举类型，这与 Rust 枚举的普遍性质保持一致（条目 1）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Shape {
    Rectangle { width: f64, height: f64 },
    Circle { radius: f64 },
}

impl Shape {
    pub fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle { width, height } =&gt; width * height,
            Shape::Circle { radius } =&gt; std::f64::consts::PI * radius * radius,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>方法的名称为它所表示的行为提供了一个标签，而方法签名为其输入和输出提供了类型信息。方法的第一个输入将是 self 的某个变体，指示该方法可能对数据结构执行的操作：</p>
<ul>
<li>&amp;self: 该参数表示方法可能读取数据结构的数据，但是并不会修改数据结构的数据内容</li>
<li>&amp;mut self: 该参数表示方法可能修改数据结构的数据内容</li>
<li>self: 该参数表示方法消耗数据结构的数据，这意味着调用者将无法再次使用数据结构（移动语意）</li>
</ul>
<h1 id="抽象行为-abstracting-behaviour"><a class="header" href="#抽象行为-abstracting-behaviour">抽象行为 （Abstracting Behaviour）</a></h1>
<p>调用一个方法总是导致执行相同的代码；从一次调用到另一次调用，变化的只是方法操作的数据。这涵盖了许多可能的场景，但如果代码需要在运行时变化怎么办？</p>
<p>Rust 在其类型系统中包含了几个特性以适应这种情况，本节将探讨这些特性。</p>
<h2 id="函数指针function-pointers"><a class="header" href="#函数指针function-pointers">（函数指针）Function Pointers</a></h2>
<p>最简单的行为抽象就是[函数指针}(https://doc.rust-lang.org/std/primitive.fn.html): 指向（仅仅是）一些代码的指针，其类型反映了函数签名。该类型在编译时进行检查，因此到程序运行时，该值仅为一个指针的大小。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn sum(x: i32, y: i32) -&gt; i32 {
        x + y
    }
    // Explicit coercion to `fn` type is required...
    let op: fn(i32, i32) -&gt; i32 = sum;
<span class="boring">}</span></code></pre></pre>
<p>函数指针没有与之相关联的其他数据,因此它们可以通过各种方式被当作值来处理:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // `fn` types implement `Copy`
    let op1 = op;
    let op2 = op;
    // `fn` types implement `Eq`
    assert!(op1 == op2);
    // `fn` implements `std::fmt::Pointer`, used by the {:p} format specifier.
    println!("op = {:p}", op);
    // Example output: "op = 0x101e9aeb0"
<span class="boring">}</span></code></pre></pre>
<p>需要注意的一个技术细节：需要使用显示强制类型转换为 <code>fn</code> 类型，因为仅仅使用函数名称你不会给你提供 <code>fn</code> 类型。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let op1 = sum;
        let op2 = sum;
        // Both op1 and op2 are of a type that cannot be named in user code,
        // and this internal type does not implement `Eq`.
        assert!(op1 == op2);
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">error[E0369]: binary operation `==` cannot be applied to type `fn(i32, i32) -&gt; i32 {main::sum}`
   --&gt; use-types-behaviour/src/main.rs:117:21
    |
117 |         assert!(op1 == op2);
    |                 --- ^^ --- fn(i32, i32) -&gt; i32 {main::sum}
    |                 |
    |                 fn(i32, i32) -&gt; i32 {main::sum}
    |
help: you might have forgotten to call this function
    |
117 |         assert!(op1( /* arguments */ ) == op2);
    |                    +++++++++++++++++++
help: you might have forgotten to call this function
    |
117 |         assert!(op1 == op2( /* arguments */ ));
    |                           +++++++++++++++++++
</code></pre>
<p>相反,编译器错误表明该类型是类似于<code>fn(i32, i32) -&gt; i32 {main::sum}</code>的东西,这是一种完全内部的编译器类型(即无法在用户代码中编写),它不仅标识了具体的函数,还标识了它的签名。换句话说,<code>sum</code>的类型同时编码了函数的签名和它的位置(<a href="https://doc.rust-lang.org/std/primitive.fn.html#creating-function-pointers">出于优化原因</a>);但是这种类型可以自动强制转换为<code>fn</code>类型(条目6)。</p>
<h2 id="闭包closures"><a class="header" href="#闭包closures">闭包（Closures）</a></h2>
<p>裸函数指针是有一些限制的，因为裸函数指针唯一可用的输入就是作为参数值显示传递的输入。</p>
<p>例如，考虑到使用一个函数指针来修改切片的元素：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // In real code, an `Iterator` method would be more appropriate.
    pub fn modify_all(data: &amp;mut [u32], mutator: fn(u32) -&gt; u32) {
        for value in data {
            *value = mutator(*value);
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>这个试用一些对切片简单的修改：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn modify_all(data: &amp;mut [u32], mutator: fn(u32) -&gt; u32) {
        for value in data {
            *value = mutator(*value);
        }
    }
    fn add2(v: u32) -&gt; u32 {
        v + 2
    }
    let mut data = vec![1, 2, 3];
    modify_all(&amp;mut data, add2);
    assert_eq!(data, vec![3, 4, 5,]);
<span class="boring">}</span></code></pre></pre>
<p>然而，如果我们的修改需要依赖外部的数据状态修改，这个就不太可能使用函数指针来做到这个事情。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn modify_all(data: &amp;mut [u32], mutator: fn(u32) -&gt; u32) {
        for value in data {
            *value = mutator(*value);
        }
    }
    let amount_to_add = 3;
    fn add_n(v: u32) -&gt; u32 {
        v + amount_to_add
    }
    let mut data = vec![1, 2, 3];
    modify_all(&amp;mut data, add_n);
    assert_eq!(data, vec![3, 4, 5,]);
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">error[E0434]: can't capture dynamic environment in a fn item
   --&gt; use-types-behaviour/src/main.rs:142:17
    |
142 |             v + amount_to_add
    |                 ^^^^^^^^^^^^^
    |
    = help: use the `|| { ... }` closure form instead
</code></pre>
<p>这个错误信息表明，我们正确的选择是使用闭包来代替函数指针：闭包是一段看起来像函数定义主体的代码(一个lambda表达式),只不过:</p>
<ul>
<li>它可以作为表达式的一部分，因为可以不需要一个单独的名称来引用它</li>
<li>输入的参数使用<code>||</code>包裹，类似<code>|param1, param2|</code>(这里参数的关联类型通常可以由编译器自动推导)</li>
<li>闭包还可以捕获上下文的变量</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let amount_to_add = 3;
    let add_n = |y| {
        // a closure capturing `amount_to_add`
        y + amount_to_add
    };
    let z = add_n(5);
    assert_eq!(z, 8);
<span class="boring">}</span></code></pre></pre>
<p>为了（粗略地）理解捕获是如何进行工作的，假设编译器创建了一个一次性的内部类型，它包含lambda表达式中提到的环境上下文的所有部分。创建闭包是，会创建临时的类型来保存相关值，并且当调用闭包时，该实例将其附加在调用上下文：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let amount_to_add = 3;
    // *Rough* equivalent to a capturing closure.
    struct InternalContext&lt;'a&gt; {
        // references to captured variables
        amount_to_add: &amp;'a u32,
    }
    impl&lt;'a&gt; InternalContext&lt;'a&gt; {
        fn internal_op(&amp;self, y: u32) -&gt; u32 {
            // body of the lambda expression
            y + *self.amount_to_add
        }
    }
    let add_n = InternalContext {
        amount_to_add: &amp;amount_to_add,
    };
    let z = add_n.internal_op(5);
    assert_eq!(z, 8);
<span class="boring">}</span></code></pre></pre>
<p>这些值在上下文保存的通常是不可变引用，但是也可以作为可变引用，或者是所有权的转移。这些值的生命周期是由闭包的生命周期来决定的。（通过使用 <code>move</code> 关键字来进行所有权的移动）</p>
<p>回到我们<code>modify_all</code>的示例中，在使用函数指针的地方抱怨不能使用闭包：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn modify_all(data: &amp;mut [u32], mutator: fn(u32) -&gt; u32) {
        for value in data {
            *value = mutator(*value);
        }
    }
    let amount_to_add = 3;
    let mut data = vec![1, 2, 3];
    modify_all(&amp;mut data, |y| y + amount_to_add);
    assert_eq!(data, vec![3, 4, 5,]);
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">error[E0308]: mismatched types
   --&gt; use-types-behaviour/src/main.rs:165:31
    |
165 |         modify_all(&amp;mut data, |y| y + amount_to_add);
    |                               ^^^^^^^^^^^^^^^^^^^^^ expected fn pointer, found closure
    |
    = note: expected fn pointer `fn(u32) -&gt; u32`
                  found closure `[closure@use-types-behaviour/src/main.rs:165:31: 165:52]`
note: closures can only be coerced to `fn` types if they do not capture any variables
   --&gt; use-types-behaviour/src/main.rs:165:39
    |
165 |         modify_all(&amp;mut data, |y| y + amount_to_add);
    |                                       ^^^^^^^^^^^^^ `amount_to_add` captured here
</code></pre>
<p>相反,接收闭包的代码必须接受某个 <code>Fn*</code> trait 的实例。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn modify_all(data: &amp;mut [u32], mutator: F)
    where 
        F: FnMut(u32) -&gt; u32
    {
        for value in data {
            *value = mutator(*value);
        }
    }
    let amount_to_add = 3;
    let mut data = vec![1, 2, 3];
    modify_all(&amp;mut data, |y| y + amount_to_add);
    assert_eq!(data, vec![3, 4, 5,]);
<span class="boring">}</span></code></pre></pre>
<p>Rust有三种不同的 <code>Fn*</code> trait，他们之间表达了该环境变量捕获的一些区别：</p>
<ul>
<li><code>FnOnce</code>：描述了只能调用一次的闭包，如果其环境变量的某些部分 <code>move</code> 进入闭包，那么<code>move</code>只能发生一次 - 对于原始的环境变量来说，这是一个所有权转移。所以该闭包智能被调用一次。</li>
<li><code>FnMut</code>：描述了可以多次调用的闭包，因为它是可变借用的，所以闭包可以修改其环境变量的部分。（但是不能被多个线程同时调用）</li>
<li><code>Fn</code>：描述了一个可以重复调用的闭包，并且它仅从环境中不可变地借用值。（可以被多个线程同时调用）</li>
</ul>
<p>编译器会自动为代码中的任何lambda表达式实现这些<code>Fn* trait</code>中的适当子集；不可能手动实现这些trait的任何一个（和C++的operator()重载不同）。</p>
<p>回到上面闭包的粗略的心理模型，编译器自动实现的那些trait大致对应捕获的环境上下文是否具有：</p>
<ul>
<li><code>FnOnce</code>：任何可移动的值</li>
<li><code>FnMut</code>：任何可变的引用（&amp;mut T）</li>
<li><code>Fn</code>：任何的不可变引用（&amp;T）</li>
</ul>
<p>上面列表中的后两个特征各自具有前面一个特征的特征界限，当你考虑使用闭包的时候，这是需要了解的。</p>
<ul>
<li>如果某个闭包期望调用一次（通过<code>FnOnce</code>来接收）,那么传递一个可以重复调用很多次的<code>FnMut</code>闭包也是完全可行的。</li>
<li>如果某个闭包期望调用多次（通过<code>FnMut</code>来接收）,那么传递一个不需要改变其环境变量的<code>Fn</code>闭包也是完全可行的。</li>
</ul>
<p>函数裸指针类型<code>fn</code>理论上也属于该列表的最后一个<code>Fn</code>，任何（非<code>unsafe</code>）<code>fn</code>类型会自动实现所有<code>Fn*</code> trait，因为它不从环境中借用任何内容，是符合所有<code>Fn*</code> trait的要求的。</p>
<p>因此，在编写接受闭包的代码时，请使用最通用的有效<code>Fn*</code> trait，以便于给调用者提供最大的灵活性 - 例如，接受<code>FnOnce</code>对于只调用一次的闭包。同样的建议，尽可能优选<code>Fn*</code> trait的函数bound，而不是使用裸指针函数的方式。</p>
<h1 id="特征traits"><a class="header" href="#特征traits">特征（Traits）</a></h1>
<p>Fn* 特征比裸函数指针更灵活，但它们仍然只能描述单个函数的行为，即使这样也只能根据函数的签名来描述。</p>
<p>然而，它们本身就是描述 Rust 类型系统行为的另一种机制的例子，即特征。特征定义了一些底层项目公开可用的一组相关方法。特征中的每个方法也有一个名称，提供一个标签，允许编译器消除具有相同签名的方法的歧义，更重要的是，它允许程序员推断出该方法的意图。</p>
<p>Rust 特征大致类似于 Go 和 Java 中的“接口”，或者 C++ 中的“抽象类”（所有虚拟方法，没有数据成员）。特征的实现必须提供所有方法（但请注意，特征定义可以包括默认实现，第 13 项），并且还可以具有这些实现使用的关联数据。这意味着代码和数据以某种面向对象的方式封装在一个公共抽象中。</p>
<p>接受 struct 并调用其方法的代码被限制为仅适用于该特定类型。如果有多种类型实现常见行为，那么定义封装该常见行为的特征并让代码使用该特征的方法而不是特定 struct 上的方法会更灵活。</p>
<p>这导致了与其他受 OO 影响的语言出现的相同类型的建议 2 ：如果预期未来的灵活性，则更喜欢接受特征类型而不是具体类型。</p>
<p>有时，您想要在类型系统中区分某些行为，但无法将其表示为特征定义中的某些特定方法签名。例如，考虑对集合进行排序的特征；实现可能是稳定的（比较相同的元素将在排序前后以相同的顺序出现），但无法在 sort 方法参数中表达这一点。</p>
<p>在这种情况下，仍然值得使用类型系统来跟踪此需求，并使用标记特征。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Sort {
    /// Re-arrange contents into sorted order.
    fn sort(&amp;mut self);
}

/// Marker trait to indicate that a [`Sortable`] sorts stably.
pub trait StableSort: Sort {}
<span class="boring">}</span></code></pre></pre>
<p>标记特征没有方法，但实现仍然必须声明它正在实现该特征 - 这充当实现者的承诺：“我郑重宣誓，我的实现排序稳定”。然后，依赖于稳定排序的代码可以指定 StableSort 特征边界，依靠荣誉系统来保留其不变量。使用标记特征来区分特征方法签名中无法表达的行为。</p>
<p>一旦行为作为特征被封装到 Rust 的类型系统中，就可以通过两种方式使用它：</p>
<ul>
<li>作为特征界限，它限制了编译时通用数据类型或方法可接受的类型，或者</li>
<li>作为特征对象。它限制了运行时可以存储或传递给方法的类型。</li>
</ul>
<p>条目 12 更详细地讨论了这些之间的权衡。</p>
<p>特征绑定指示由某种类型 T 参数化的通用代码只能在该类型 T 实现某些特定特征时使用。特征绑定的存在意味着泛型的实现可以使用该特征中的方法，因为编译器将确保编译的任何 T 确实具有这些方法。这种检查发生在编译时，此时泛型是单态的（Rust 的 C++ 术语称为“模板实例化”）。</p>
<p>对目标类型 T 的这种限制是显式的，编码在特征边界中：特征只能由满足特征边界的类型实现。这与 C++ 中的等效情况形成对比，其中对 template<typename T> 中使用的类型 T 的约束是隐式的 3 ：C++ 模板代码仍然只能编译如果所有引用的方法在编译时都可用，但检查纯粹基于方法和签名。 （这种“鸭子类型”可能会导致混淆；使用 t.pop() 的 C++ 模板可能会编译为 Stack 或 Balloon – 这不太可能是理想的行为。）</p>
<p>对显式特征界限的需求也意味着很大一部分泛型使用特征界限。要了解其中的原因，请扭转观察并考虑在 T 上没有特征边界的情况下可以使用 struct Thing<T> 做什么。如果没有特征绑定， Thing 只能执行适用于任何类型 T 的操作；这允许容器、集合和智能指针，但仅此而已。任何使用 T 类型的东西都需要一个特征绑定。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn dump_sorted&lt;T&gt;(mut collection: T)
where
    T: Sort + IntoIterator,
    T::Item: Debug,
{
    // Next line requires `T: Sort` trait bound.
    collection.sort();
    // Next line requires `T: IntoIterator` trait bound.
    for item in collection {
        // Next line requires `T::Item : Debug` trait bound
        println!("{:?}", item);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>因此，这里的建议是使用特征边界来表达对泛型中使用的类型的要求，但这是很容易遵循的建议 - 无论如何，编译器都会强制您遵守它。</p>
<p>特征对象是利用特征定义的封装的另一种方式，但这里特征的不同可能实现是在运行时而不是编译时选择的。这种动态分派类似于 C++ 中虚拟函数的使用，并且 Rust 的底层具有与 C++ 中的大致类似的“vtable”对象。</p>
<p>特征对象的这种动态方面还意味着它们始终必须通过引用（ &amp;dyn Trait ）或指针（ Box<dyn Trait> ）间接处理。这是因为实现该特征的对象的大小在编译时是未知的 - 它可能是一个巨大的 struct 或一个很小的 ​​ enum - 所以没有办法分配正确的裸特征对象的空间量。</p>
<p>类似的担忧意味着用作特征对象的特征不能具有返回 Self 类型的方法，因为使用特征对象的预先编译的代码不知道 Self 有多大b1&gt; 可能是。</p>
<p>对于可能存在的所有不同类型 T ，具有通用方法 fn method<T>(t:T) 的特征允许无限数量的实现方法。这对于用作特征边界的特征来说很好，因为可能调用的泛型方法的无限集在编译时变成了实际调用的泛型方法的有限集。对于特征对象来说情况并非如此：编译时可用的代码必须处理运行时可能到达的所有可能的 T 。</p>
<p>这两个限制——不返回 Self 和没有泛型方法——被结合到对象安全的概念中。只有对象安全特征才能用作特征对象。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Types/Item1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Types/Item1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
