<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>effective-rust-cn</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Cover.html"><strong aria-hidden="true">1.</strong> Cover</a></li><li class="chapter-item expanded "><a href="Introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="Types.html"><strong aria-hidden="true">3.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Types/Item1.html"><strong aria-hidden="true">3.1.</strong> Item 1: Use the type system to express your data structures</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">effective-rust-cn</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="effective-rust-cn"><a class="header" href="#effective-rust-cn">Effective Rust CN</a></h1>
<h2 id="35种提高你rust代码的具体方法"><a class="header" href="#35种提高你rust代码的具体方法">35种提高你Rust代码的具体方法</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<pre><code>"The code is more what you'd call 'guidelines' than actual rules." – Hector Barbossa
</code></pre>
<p>斯科特·迈耶斯的《Effective C++》因为引入了一种新式的编程书籍风格而取得非凡的成功，这种风格专注于一系列从C++软件开发实际经验中学到的指导原则的集合。值得注意的是，这些指导原则不仅解释它们存在的必要性而且还允许读者自己决定他们特定的场景是否需要打破这些指导规则。</p>
<p>《Effective C++》的第一版出版于1992年，那时的C++语言虽然年轻，但已经是一种包含许多潜在问题的微妙语言；拥有一个指导其不同特性相互作用的指南是必不可少的。</p>
<p>相比之下，Rust也是一门年轻的语言，但它几乎不含潜在的问题。其类型系统的强度一致性意味着，如果一个Rust程序编译通过了，它就已经有相当大的可能性会正常工作——这种现象以前只在更学术性、不那么容易感知到的语言中观察到，比如Haskell。</p>
<p>Rust安全性——包括类型安全和内存安全 —— 虽然有代价。Rust因其学习曲线陡峭而闻名，入门者必须经历与借用检查器斗争、重新设计数据结构以及对生命周期感到困惑的入门仪式。一个编译通过的Rust程序可能很有可能直接工作，但让它编译通过内心所遭受的斗争是真实的——即使Rust编译器提供的错误诊断非常有帮助。</p>
<p>因此，这本书的目标读者与其他《Effective <Language>》系列书籍略有不同；这里有更多的项目涵盖了Rust的新概念，尽管官方文档已经包含了这些主题的良好介绍。这些项目的标题如“理解……”和“熟悉……”。</p>
<p>Rust的安全性也导致了完全没有标题为“永不……”的项目。如果你真的不应该做某事，编译器通常会阻止你这么做。（译者备注：这就是Rust编译器的自信，不该干的，不会让你干）</p>
<p>尽管如此，文本仍然假定读者对语言的基础有所了解。它还假设使用的是2018版的Rust，并使用稳定的工具链。</p>
<p>用于代码片段和错误消息的具体rustc版本是1.60。Rust现在已经足够稳定（并有足够的向后兼容保证），代码片段不太可能需要为后续版本做出更改，但错误消息可能会因你的特定编译器版本而有所不同。</p>
<p>文本还有许多参考和与C++的比较，因为这可能是最接近的等效语言（特别是具有C++11的移动语义），也是Rust新手最可能遇到的前一种语言。</p>
<p>所有的项目被分为如下六个片段：</p>
<ul>
<li>Types(类型)：围绕Rust核心系统的建议</li>
<li>Concepts(概念)：Rust设计的核心概念</li>
<li>Dependencies(依赖)：关于如何使用Rust的包生态系统的建议（更多的是对cargo的理解和使用）</li>
<li>Tools(工具)：关于如何通过不仅仅是使用Rust编译器来改进代码库的建议。</li>
<li>Asynchronous Rust(异步Rust)：和Rust async机制的工作方式的建议</li>
<li>Beyond Standard Rust(额外的Rust)：当你需要在Rust的标准、安全环境之外工作时的建议。（更多的是unsafe的一些建议）</li>
</ul>
<p>虽然“概念”部分可以说比“类型”部分更为基础，但它故意放在第二位，以便从头到尾阅读的读者可以先建立一些信心。（其实我们懂作者这句话，从我的理解，应该是第二部分也给一点简单的东西，好让有继续读下去的信心）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>这本书的第一部分涵盖了围绕Rust类型系统的建议。这个类型系统比其他主流语言的类型系统更具表达力；它与诸如OCaml或Haskell这样的“学术”语言有更多共同之处。</p>
<p>其中一个核心部分是Rust的枚举类型，这比其他语言中的枚举类型具有更高的表达力，并且允许使用代数数据类型。</p>
<p>Rust类型系统的另一个核心支柱是特征类型（trait type）。特征大致相当于其他语言中的接口类型，但它们也与Rust的泛型（项目12）相关联，以允许在没有运行时开销的情况下重用接口。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目-1-使用类型系统表达你的数据结构"><a class="header" href="#项目-1-使用类型系统表达你的数据结构">项目 1: 使用类型系统表达你的数据结构</a></h1>
<pre><code>"who called them programers and not type writers" – @thingskatedid
</code></pre>
<p>Rust类型系统的基础对于来自另一种静态类型编程语言（如C++、Go或Java）的人来说相当熟悉。这里有一系列具体大小的整数类型，包括有符号（<code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code>）和无符号（<code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code>）。</p>
<p>还有有符号（<code>isize</code>）和无符号（<code>usize</code>）整数，其大小与目标系统上的指针大小相匹配。Rust不是一种需要在指针和整数之间进行大量转换的语言，因此这种描述并不真正相关。然而，标准集合以<code>usize</code>（来自<code>.len()</code>）返回它们的大小，所以集合索引意味着usize值相当常见——从容量角度看这显然是可以的，因为系统上的内存地址数量多于内存中集合的项目数量。</p>
<p>整数类型确实给我们提供了第一个暗示，即Rust是一个比C++更严格的世界——试图将（<code>i32</code>）放入（<code>i16</code>）的容器中会生成一个编译时错误。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>         let x: i32 = 42;
         let y: i16 = x;
<span class="boring">}</span></code></pre></pre>
<p>这段代码会产生如下错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:14:22
   |
14 |         let y: i16 = x;
   |                ---   ^ expected `i16`, found `i32`
   |                |
   |                expected due to this
   |
help: you can convert an `i32` to an `i16` and panic if the converted value doesn't fit
   |
14 |         let y: i16 = x.try_into().unwrap();
   |                       ++++++++++++++++++++
<span class="boring">}</span></code></pre></pre>
<p>这令人非常安心：Rust不会在程序员进行风险操作时静静地坐在那里。Rust不但显示出有更严格的规则，而且它也有有用的编译器消息，指出如何遵守这些规则。建议的解决方案引发了一个问题，即如何处理转换可能改变值的情况，我们稍后还会在错误处理（项目4）和使用panic!（项目18）上有更多讨论。</p>
<p>Rust还不允许一些可能看似“安全”的操作：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let x = 42i32; // Integer literal with type suffix
        let y: i64 = x;
<span class="boring">}</span></code></pre></pre>
<p>这段代码会产生如下错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:23:22
   |
23 |         let y: i64 = x;
   |                ---   ^ expected `i64`, found `i32`
   |                |
   |                expected due to this
   |
help: you can convert an `i32` to an `i64`
   |
23 |         let y: i64 = x.into();
   |                       +++++++

<span class="boring">}</span></code></pre></pre>
<p>在这里，建议的解决方案并没有提出错误处理的问题，但转换仍然需要是显式的。我们稍后将更详细地讨论类型转换（项目6）。</p>
<p>继续介绍基本的原始类型，Rust包括用于布尔值的<code>bool</code>类型，浮点类型（<code>f32</code>、<code>f64</code>）以及类似于C语言中的void的单位类型<code>()</code>。</p>
<p>更值得注意的是，Rust具有<code>char</code>字符类型，它存储一个Unicode值，类似于Go的<code>rune</code>类型。虽然内部存储为4字节，但Rust不允许将其自由地转换为32位整数或从32位整数转换得来</p>
<p>这种类型系统的严谨性强制你在代码中明确表达 —— 一个<code>u32</code>值与一个<code>char</code>不同，与一串UTF-8字节不同，与一串任意字节不同。定义你正在操作的内存取决于你。乔尔·斯波尔斯基（Joel Spolsky）关于Unicode的<a href="Types/!https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">著名博客文章</a>可以帮助理解这些差异。</p>
<p>虽然Rust提供了帮助方法来转换这些不同的类型，但它们的签名要求你管理或明确忽略转换错误的风险。例如，任何Unicode代码点都可以用32位表示，因此将'a'转换为u32是允许的。然而，从u32转换为char则更复杂，因为可能存在无效的Unicode代码点。</p>
<ul>
<li><code>char::from_u32</code> 返回一个<code>Option&lt;char&gt;</code>，强制要求调用者来处理错误的情况</li>
<li><code>char::from_u32_unchecked</code> 假定输入是有效的Unicode代码点，这样就可以避免运行时检查，但是它的结果是需要标记位<code>unsafe</code>的，强制调用者也是unsafe的(项目16相关)</li>
</ul>
<h1 id="聚合类型aggregate-types"><a class="header" href="#聚合类型aggregate-types">聚合类型（Aggregate Types）</a></h1>
<p>继续讨论聚合类型，Rust有：</p>
<ul>
<li>数组（Array），它们包含多个单一类型的实例，其中实例的数量在编译时已知。例如，[u32; 4] 是连续的四个4字节整数。</li>
<li>元组（Tuples），它包含很多异构类型的实例，其中实例的数量和类型在编译时已知。例如，(WidgetOffset, WidgetSize, WidgetColour)。如果元组中的类型不是独特的 —— 例如(i32, i32, &amp;'static str, bool) —— 最好给每个元素一个名字，并使用结构体</li>
<li>结构体（Structs），它们也包含在编译时已知的异质类型的实例，但允许通过名称引用整体类型和各个字段。</li>
</ul>
<p>元组结构是结构体和元组的混合体：整体类型有一个名称，但个别字段没有名称——它们通过数字来引用，例如：s.0, s.1 等。</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
    struct TextMatch(usize, String);
    let m = TextMatch(12, "needle".to_owned());
    assert_eq!(m.0, 12);
}</code></pre></pre>
<p>这引出了Rust类型系统中的王冠上的宝石——enum。</p>
<p>在其基本形式中，很难看出有什么值得激动的地方。与其他语言类似，枚举允许你指定一组互斥的值，可能附带有数字或字符串值。</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
    enum HttpResultCode {
        Ok = 200,
        NotFound = 404,
        Teapot = 418,
    }
    let code = HttpResultCode::NotFound;
    assert_eq!(code as i32, 404);
}</code></pre></pre>
<p>因为每一个<code>enum</code>定义创建了不同的类型，这个可以提高如下函数的可读性以及维护性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        print_page(/* both_sides= */ true, /* colour= */ false);
<span class="boring">}</span></code></pre></pre>
<p>上述函数的使用<code>enum</code>的新版本：</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
    pub enum Sides {
        Both,
        Single,
    }

    pub enum Output {
        BlackAndWhite,
        Colour,
    }

    pub fn print_page(sides: Sides, colour: Output) {
        // ...
    }
}</code></pre></pre>
<p>这种方式类型安全更加有保障，而且给调用者来说也是更加直观的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        print_page(Sides::Both, Output::BlackAndWhite);
<span class="boring">}</span></code></pre></pre>
<p>不像bool版本，如果库的使用者不小心将参数的顺序搞错了，那么编译器就会立即抱怨，让你知道你犯了一个错误。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:89:20
   |
89 |         print_page(Output::BlackAndWhite, Sides::Single);
   |                    ^^^^^^^^^^^^^^^^^^^^^ expected enum `enums::Sides`, found enum `enums::Output`
error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:89:43
   |
89 |         print_page(Output::BlackAndWhite, Sides::Single);
   |                                           ^^^^^^^^^^^^^ expected enum `enums::Output`, found enum `enums::Sides`

<span class="boring">}</span></code></pre></pre>
<p>（使用新类型模式（项目7）来包装布尔值也可以实现类型安全和可维护性；如果语义将始终是布尔值，通常最好使用该方法，并且如果将来可能出现新的替代项（例如 Sides::BothAlternateOrientation），则使用枚举。）</p>
<p>Rust的枚举的类型安全性在匹配表达式中继续体现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let msg = match code {
            HttpResultCode::Ok =&gt; "Ok",
            HttpResultCode::NotFound =&gt; "Not found",
            // forgot to deal with the all-important "I'm a teapot" code
        };
<span class="boring">}</span></code></pre></pre>
<p>这段代码会产生如下错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0004]: non-exhaustive patterns: `Teapot` not covered
  --&gt; use-types/src/main.rs:65:25
   |
51 | /     enum HttpResultCode {
52 | |         Ok = 200,
53 | |         NotFound = 404,
54 | |         Teapot = 418,
   | |         ------ not covered
55 | |     }
   | |_____- `HttpResultCode` defined here
...
65 |           let msg = match code {
   |                           ^^^^ pattern `Teapot` not covered
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `HttpResultCode`

<span class="boring">}</span></code></pre></pre>
<p>编译器强制程序员考虑枚举表示的所有可能性，即使结果只是添加一个默认分支 _ =&gt; {}。（需要注意的是，现代C++编译器也可以警告缺少枚举<code>switch</code>分支。）</p>
<h1 id="带字段的enums"><a class="header" href="#带字段的enums">带字段的enums</a></h1>
<p>Rust枚举功能的真正威力来自于每个变体都可以携带数据，使其成为代数数据类型（ADT）。对于主流语言的程序员来说，这可能不太熟悉；从C/C++的角度来看，它就像是枚举与联合的组合——只不过是类型安全的。</p>
<p>这意味着程序数据结构的不变性可以编码到Rust的类型系统中；不符合这些不变性的状态甚至不会编译通过。一个设计良好的枚举能够使创作者的意图清晰地传达给人类和编译器：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SchedulerState {
    Inert,
    Pending(HashSet&lt;Job&gt;),
    Running(HashMap&lt;CpuId, Vec&lt;Job&gt;&gt;),
}
<span class="boring">}</span></code></pre></pre>
<p>仅仅从类型定义，我们可以合理地猜测，任务会在挂起状态中排队，直到调度程序完全激活，然后它们会分配给每个CPU池。</p>
<p>这突显了这个项目的中心主题，即利用Rust的类型系统来表达与软件设计相关的概念。</p>
<p>一个明显的迹象表明这种情况并未发生是，当一些字段或参数的有效性需要解释时，会有注释说明：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DisplayProps {
    x: u32,
    y: u32,
    monochrome: bool,
    // `fg_colour` must be (0, 0, 0) if `monochrome` is true.
    fg_colour: RgbColour,
}
<span class="boring">}</span></code></pre></pre>
<p>这是一个非常适合用包含数据的枚举替换的候选对象：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
enum Colour {
    Monochrome,
    Foreground(RgbColour),
}

struct DisplayProperties {
    x: u32,
    y: u32,
    colour: Colour,
}
<span class="boring">}</span></code></pre></pre>
<p>这个小例子说明了一个关键建议：使类型中的无效状态来表达无效。只支持有效值组合的类型意味着编译器会拒绝整类错误，从而产生更小、更安全的代码。</p>
<h1 id="options-和-errors"><a class="header" href="#options-和-errors">Options 和 Errors</a></h1>
<p>回到枚举的强大之处，有两个概念是如此常见，以至于Rust包含了内置的枚举类型来表达它们。</p>
<p>第一个概念是<code>Option</code>：要么有特定类型的值（<code>Some(T)</code>），要么没有（<code>None</code>）。对于可能不存在的值，始终使用Option；永远不要退回到使用标记值（-1、nullptr等）来尝试表示相同的概念。</p>
<p>然而，还有一个微妙的要考虑的地方。如果你处理的是一组东西，你需要决定是否拥有零个东西在集合中与没有集合是相同的。对于大多数情况，这个区别并不存在，你可以直接使用Vec<Thing>：零个东西的计数意味着没有东西。</p>
<p>然而，确实存在其他少见的情况，需要使用Option&lt;Vec<Thing>&gt; 来区分这两种情况 —— 例如，加密系统可能需要区分“分开传输的有效载荷”和“提供了空有效载荷”。（这与SQL中的NULL标记列的争论有关。）</p>
<p>一个常见的临界情况是可能不存在的字符串 - 使用 "" 还是 None 更合理来表示值的缺失？两种方式都可以，但 Option<String> 清楚地传达了这个值可能不存在的可能性。</p>
<p>第二个常见概念源自错误处理：如果一个函数失败了，该如何报告这个失败？在历史上，特殊的标记值（例如来自Linux系统调用的 -errno 返回值）或全局变量（POSIX系统的 errno）被使用。最近，支持从函数返回多个或元组返回值的语言（如Go）可能有一个约定，即在错误为非“零”时返回（结果，错误）对。</p>
<p>在Rust中，总是将可能失败的操作的结果编码为 Result&lt;T, E&gt;。T 类型保存成功的结果（在 Ok 变体中），E 类型在失败时保存错误详情（在 Err 变体中）。使用标准类型可以清晰地表达设计意图，并允许使用标准转换（项目3）和错误处理（项目4）；它还使得通过 ? 操作符来简化错误处理成为可能。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
