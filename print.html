<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>effective-rust-cn</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Cover.html"><strong aria-hidden="true">1.</strong> 封面</a></li><li class="chapter-item expanded "><a href="Introduction.html"><strong aria-hidden="true">2.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="Types.html"><strong aria-hidden="true">3.</strong> 类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Types/Item1.html"><strong aria-hidden="true">3.1.</strong> 条目 1: 使用类型系统表达你的数据结构</a></li><li class="chapter-item expanded "><a href="Types/Item2.html"><strong aria-hidden="true">3.2.</strong> 条目 2：使用类型系统来表达常见行为</a></li><li class="chapter-item expanded "><a href="Types/Item3.html"><strong aria-hidden="true">3.3.</strong> 条目 3: 避免在Option和Result类型上使用match操作</a></li><li class="chapter-item expanded "><a href="Types/Item4.html"><strong aria-hidden="true">3.4.</strong> 条目 4: 优先惯用的Error类型</a></li><li class="chapter-item expanded "><a href="Types/Item5.html"><strong aria-hidden="true">3.5.</strong> 条目 5：了解类型转换</a></li><li class="chapter-item expanded "><a href="Types/Item6.html"><strong aria-hidden="true">3.6.</strong> 条目 6: 拥抱新类型</a></li><li class="chapter-item expanded "><a href="Types/Item7.html"><strong aria-hidden="true">3.7.</strong> 条目 7: 使用Builders来构建复杂的类型</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">effective-rust-cn</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Milittle/effective-rust-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="effective-rustrust效率之道"><a class="header" href="#effective-rustrust效率之道">Effective Rust（Rust效率之道）</a></h1>
<h2 id="35种提高你rust代码的具体方法"><a class="header" href="#35种提高你rust代码的具体方法">35种提高你Rust代码的具体方法</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<pre><code>"The code is more what you'd call 'guidelines' than actual rules." – Hector Barbossa
</code></pre>
<p>斯科特·迈耶斯的《Effective C++》因为引入了一种新式的编程书籍风格而取得非凡的成功，这种风格专注于一系列从C++软件开发实际经验中学到的指导规则。值得注意的是，这些指导原则不仅解释它们存在的必要性而且还允许读者在特定的场景自己决定是否需要打破这些指导规则。</p>
<p>《Effective C++》的第一版出版于1992年，那时的C++语言虽然年轻，但已经是一种包含许多潜在问题的微妙语言；拥有一个指南来指导不同特性之间相互的作用是必不可少的。</p>
<p>相比之下，Rust如今是正值少年，相比C++它几乎不包含潜在的问题。其类型系统的强度一致性能确保如果一个Rust程序编译通过了，它就已经有很大的概率可以正常运行 —— 这种现象以前只在更学术化、不那么容易感知到的语言中观察到，比如Haskell。</p>
<p>Rust安全性——包括类型安全和内存安全 —— 虽然有代价。Rust因其学习曲线陡峭而闻名，入门者必须经历与借用检查器斗争、重新设计数据结构以及对生命周期感到困惑的入门仪式。一个编译通过的Rust程序很大概率可以非常健壮的运行，但让它编译通过内心所遭受的斗争是真实的——即使Rust编译器提供的错误诊断非常有帮助。</p>
<p>因此，这本书的目标读者与其他《Effective <Language>》系列书籍略有不同；这里有更多的项目涵盖了Rust的新概念，尽管官方文档已经包含了这些主题的良好介绍。这些项目的标题如“理解……”和“熟悉……”。</p>
<p>Rust的安全性也导致了完全没有标题为“永不……”的项目。如果你真的不应该做某事，编译器通常会阻止你这么做。（译者备注：这就是Rust编译器的自信，不该干的，不会让你干）</p>
<p>尽管如此，文本仍然假定读者对语言的基础有所了解。使用的是2018版的Rust，并使用稳定的工具链。</p>
<p>用于代码片段和错误消息的具体rustc版本是1.60。Rust现在已经足够稳定（并有足够的向后兼容保证），代码片段不太可能需要为后续版本做更改，但错误消息可能会因你的编译器版本而有所不同。</p>
<p>本文还有许多参考C++以及与C++进行比较的地方，因为这可能是最接近的等效语言（特别是具有C++11的移动语义），也是Rust新手最可能遇到的前一种语言。</p>
<p>所有的项目被分为如下六个片段：</p>
<ul>
<li>Types(类型)：围绕Rust核心系统的建议</li>
<li>Concepts(概念)：Rust设计的核心概念</li>
<li>Dependencies(依赖)：关于如何使用Rust的包生态系统的建议（更多的是对cargo的理解和使用）</li>
<li>Tools(工具)：关于如何通过除了Rust编译器以外的工具来改进代码的建议。</li>
<li>Asynchronous Rust(异步Rust)：使用Rust async机制时的一些建议</li>
<li>Beyond Standard Rust(额外的Rust)：当你需要在Rust的标准、安全环境之外工作时的建议。（更多的是unsafe的一些建议）</li>
</ul>
<p>虽然“概念”部分可以说比“类型”部分更为基础，但刻意放在第二位，以便从头到尾阅读的读者先建立一些信心。（其实我们懂作者这句话，从我的理解，应该是第二部分也给一点简单的东西，好让读者有继续读下去的信心）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>这本书的第一部分涵盖了围绕Rust类型系统的建议。这个类型系统比其他主流语言的类型系统更具表达力；它与诸如OCaml或Haskell这样的“学术”语言有更多共同之处。</p>
<p>其中一个核心部分是Rust的枚举类型，这比其他语言中的枚举类型具有更高的表达力，并且允许使用<a href="https://en.wikipedia.org/wiki/Algebraic_data_type">ADT</a>。</p>
<p>Rust类型系统的另一个核心是特征类型（trait type）。特征大致相当于其他语言中的接口类型，但它们也与Rust的泛型（条目 12）相关联，以允许在没有运行时开销的情况下重用接口。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条目-1-使用类型系统表达你的数据结构"><a class="header" href="#条目-1-使用类型系统表达你的数据结构">条目 1: 使用类型系统表达你的数据结构</a></h1>
<pre><code>"who called them programers and not type writers" – @thingskatedid
</code></pre>
<p>Rust类型系统的基础对于熟悉另一种静态类型编程语言（如C++、Go或Java）的人来说相当熟悉。这里有一系列具体大小的整数类型，包括有符号（<a href="https://doc.rust-lang.org/std/primitive.i8.html"><code>i8</code></a>、<a href="https://doc.rust-lang.org/std/primitive.i16.html"><code>i16</code></a>、<a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>、<a href="https://doc.rust-lang.org/std/primitive.i64.html"><code>i64</code></a>、<a href="https://doc.rust-lang.org/std/primitive.i64.html"><code>i128</code></a>）和无符号（<a href="https://doc.rust-lang.org/std/primitive.u8.html"><code>u8</code></a>、<a href="https://doc.rust-lang.org/std/primitive.u16.html"><code>u16</code></a>、<a href="https://doc.rust-lang.org/std/primitive.u32.html"><code>u32</code></a>、<a href="https://doc.rust-lang.org/std/primitive.u64.html"><code>u64</code></a>、<a href="https://doc.rust-lang.org/std/primitive.u128.html"><code>u128</code></a>）。</p>
<p>还有有符号（<a href="https://doc.rust-lang.org/std/primitive.isize.html"><code>isize</code></a>）和无符号（<a href="https://doc.rust-lang.org/std/primitive.usize.html"><code>usize</code></a>）整数，其大小与目标系统上的指针大小相匹配。Rust不是一种需要在指针和整数之间进行大量转换的语言，因此这种描述并不真正相关。然而，标准集合以<code>usize</code>（来自<code>.len()</code>）返回它们的大小，所以集合索引意味着usize值相当常见——从容量角度看这显然是可以的，因为系统上的内存地址数量多于内存中集合的项目数量。</p>
<p>整数类型确实给我们提供了第一个暗示，即Rust是一个比C++更严格的世界——试图将（<code>i32</code>）放入（<code>i16</code>）的容器中会生成一个编译时错误。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>         let x: i32 = 42;
         let y: i16 = x;
<span class="boring">}</span></code></pre></pre>
<p>这段代码会产生如下错误：</p>
<pre><code class="language-shell">error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:14:22
   |
14 |         let y: i16 = x;
   |                ---   ^ expected `i16`, found `i32`
   |                |
   |                expected due to this
   |
help: you can convert an `i32` to an `i16` and panic if the converted value doesn't fit
   |
14 |         let y: i16 = x.try_into().unwrap();
   |                       ++++++++++++++++++++
</code></pre>
<p>这令人非常安心：Rust不会在程序员进行风险操作时坐视不管。Rust不但显示有更严格的规则，而且它也有有用的编译器提示，指出如何遵守这些规则。建议的解决方案引发了出一个问题，即如何处理由于转换而可能改变值的情况，我们稍后还会在错误处理（条目 4）和使用<code>panic!</code>（条目 18）上有更多讨论。</p>
<p>Rust还不允许一些可能看似 “安全” 操作的转换：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let x = 42i32; // Integer literal with type suffix
        let y: i64 = x;
<span class="boring">}</span></code></pre></pre>
<p>这段代码会产生如下错误：</p>
<pre><code class="language-shell">error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:23:22
   |
23 |         let y: i64 = x;
   |                ---   ^ expected `i64`, found `i32`
   |                |
   |                expected due to this
   |
help: you can convert an `i32` to an `i64`
   |
23 |         let y: i64 = x.into();
   |                       +++++++

</code></pre>
<p>在这里，建议的解决方案并没有提出错误处理的问题，但转换仍然需要是显式的。我们稍后将更详细地讨论类型转换（条目 6）。</p>
<p>继续介绍基本的原始类型，Rust包括用于布尔值的<a href="https://doc.rust-lang.org/std/primitive.bool.html"><code>bool</code></a>类型，浮点类型（<a href="https://doc.rust-lang.org/std/primitive.f32.html"><code>f32</code></a>、<a href="https://doc.rust-lang.org/std/primitive.f64.html"><code>f64</code></a>）以及类似于C语言中的void类型<a href="https://en.wikipedia.org/wiki/Unit_type"><code>()</code></a>。</p>
<p>更值得注意的是，Rust具有<a href="https://doc.rust-lang.org/std/primitive.char.html"><code>char</code></a>类型，它存储一个<a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode值</a>，类似于Go的<a href="https://golang.org/doc/go1#rune"><code>rune</code></a>类型。虽然内部存储为4字节，但Rust不允许将其自由地与32位整型进行互相转换。</p>
<p>这种类型系统的严谨性强制你在代码中明确表达 —— 一个<code>u32</code>值与一个<code>char</code>不同，与一串UTF-8字节不同，与一串任意字节不同。定义你正在操作的内存取决于你。乔尔·斯波尔斯基（Joel Spolsky）关于Unicode的<a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">著名博客文章</a>可以帮助理解这些差异。</p>
<p>虽然Rust提供了帮助方法来转换这些不同的类型，但它们的签名要求你管理或明确忽略转换错误的风险。例如，任何Unicode代码点都可以用32位表示，因此将'a'转换为u32是允许的。然而，从u32转换为char则更复杂，因为可能存在无效的Unicode代码点。</p>
<ul>
<li><code>char::from_u32</code> 返回一个<code>Option&lt;char&gt;</code>，强制要求调用者来处理错误的情况</li>
<li><code>char::from_u32_unchecked</code> 假定输入是有效的Unicode代码点，这样就可以避免运行时检查，但是它的结果是需要标记位<code>unsafe</code>的，强制调用者是unsafe的使用(条目 16 相关)</li>
</ul>
<h1 id="聚合类型aggregate-types"><a class="header" href="#聚合类型aggregate-types">聚合类型（Aggregate Types）</a></h1>
<p>继续讨论聚合类型，Rust有：</p>
<ul>
<li>数组（Arrays），它们包含多个单一类型的实例，其中实例的数量在编译时已知。例如，[u32; 4] 是连续的四个4字节整数。</li>
<li>元组（Tuples），它包含很多异构类型的实例，其中实例的数量和类型在编译时已知。例如，(WidgetOffset, WidgetSize, WidgetColour)。如果元组中的类型不是独特的 —— 例如(i32, i32, &amp;'static str, bool) —— 最好给每个元素一个名字，并使用结构体</li>
<li>结构体（Structs），它们也包含在编译时已知的异质类型的实例，但允许通过名称引用整体类型和各个字段。</li>
</ul>
<p>元组结构是结构体和元组的混合体：整体类型有一个名称，但个别字段没有名称——它们通过数字来引用，例如：s.0, s.1 等。</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
    struct TextMatch(usize, String);
    let m = TextMatch(12, "needle".to_owned());
    assert_eq!(m.0, 12);
}</code></pre></pre>
<p>这引出了Rust类型系统中的王冠上的宝石 —— <code>enum</code>。</p>
<p>在其基本形式中，很难看出有什么值得激动的地方。与其他语言类似，枚举允许你指定一组互斥的值，可能附带有数字或字符串值。</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
    enum HttpResultCode {
        Ok = 200,
        NotFound = 404,
        Teapot = 418,
    }
    let code = HttpResultCode::NotFound;
    assert_eq!(code as i32, 404);
}</code></pre></pre>
<p>因为每一个<code>enum</code>定义创建了不同的类型，这个可以提高如下函数的可读性以及维护性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        print_page(/* both_sides= */ true, /* colour= */ false);
<span class="boring">}</span></code></pre></pre>
<p>上述函数的使用<code>enum</code>的新版本：</p>
<pre><pre class="playground"><code class="language-rust">#![allow(unused)]
fn main() {
    pub enum Sides {
        Both,
        Single,
    }

    pub enum Output {
        BlackAndWhite,
        Colour,
    }

    pub fn print_page(sides: Sides, colour: Output) {
        // ...
    }
}</code></pre></pre>
<p>这种方式类型安全更加有保障，而且给调用者来说也是更加直观的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        print_page(Sides::Both, Output::BlackAndWhite);
<span class="boring">}</span></code></pre></pre>
<p>不像<code>bool</code>的函数版本，如果库的使用者不小心将参数的顺序搞错了，那么编译器就会立即抱怨，让你知道你犯了错误。</p>
<pre><code class="language-shell">error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:89:20
   |
89 |         print_page(Output::BlackAndWhite, Sides::Single);
   |                    ^^^^^^^^^^^^^^^^^^^^^ expected enum `enums::Sides`, found enum `enums::Output`
error[E0308]: mismatched types
  --&gt; use-types/src/main.rs:89:43
   |
89 |         print_page(Output::BlackAndWhite, Sides::Single);
   |                                           ^^^^^^^^^^^^^ expected enum `enums::Output`, found enum `enums::Sides`

</code></pre>
<p>（使用新类型模式（条目 7）来包装布尔值也可以实现类型安全和可维护性；如果语义将始终是布尔值，通常最好使用该方法，并且如果将来可能出现新的替代项（例如 Sides::BothAlternateOrientation），则使用枚举。）</p>
<p>Rust的枚举的类型安全性在匹配表达式中继续体现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let msg = match code {
            HttpResultCode::Ok =&gt; "Ok",
            HttpResultCode::NotFound =&gt; "Not found",
            // forgot to deal with the all-important "I'm a teapot" code
        };
<span class="boring">}</span></code></pre></pre>
<p>这段代码会产生如下错误：</p>
<pre><code class="language-shell">error[E0004]: non-exhaustive patterns: `Teapot` not covered
  --&gt; use-types/src/main.rs:65:25
   |
51 | /     enum HttpResultCode {
52 | |         Ok = 200,
53 | |         NotFound = 404,
54 | |         Teapot = 418,
   | |         ------ not covered
55 | |     }
   | |_____- `HttpResultCode` defined here
...
65 |           let msg = match code {
   |                           ^^^^ pattern `Teapot` not covered
   |
   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms
   = note: the matched value is of type `HttpResultCode`

</code></pre>
<p>编译器强制程序员考虑枚举表示的所有可能性，即使结果只是添加一个默认分支 _ =&gt; {}。（需要注意的是，现代C++编译器也可以警告缺少枚举<code>switch</code>分支。）</p>
<h1 id="带字段的enums"><a class="header" href="#带字段的enums">带字段的enums</a></h1>
<p>Rust枚举功能的真正威力来自于每个变体都可以携带数据，使其成为代数数据类型（ADT）。对于主流语言的程序员来说，这可能不太熟悉；从C/C++的角度来看，它就像是枚举与联合的组合 —— 只不过是类型安全的。</p>
<p>这意味着程序数据结构的不变性可以编码到Rust的类型系统中；不符合这些不变性的状态甚至不会编译通过。一个设计良好的枚举能够使创作者的意图清晰地传达给人类和编译器：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum SchedulerState {
    Inert,
    Pending(HashSet&lt;Job&gt;),
    Running(HashMap&lt;CpuId, Vec&lt;Job&gt;&gt;),
}
<span class="boring">}</span></code></pre></pre>
<p>仅仅从类型定义，我们可以合理地猜测，任务会在挂起状态中排队，直到调度程序完全激活，然后它们会分配给每个CPU池。</p>
<p>这突显了这个项目的中心主题，即利用Rust的类型系统来表达与软件设计相关的概念。</p>
<p>一个明显的迹象表明这种情况并未发生是，当一些字段或参数的有效性需要解释时，会使用注释说明：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DisplayProps {
    x: u32,
    y: u32,
    monochrome: bool,
    // `fg_colour` must be (0, 0, 0) if `monochrome` is true.
    fg_colour: RgbColour,
}
<span class="boring">}</span></code></pre></pre>
<p>这是一个非常适合用包含数据的枚举替换的候选对象：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
enum Colour {
    Monochrome,
    Foreground(RgbColour),
}

struct DisplayProperties {
    x: u32,
    y: u32,
    colour: Colour,
}
<span class="boring">}</span></code></pre></pre>
<p>这个小例子说明了一个关键建议：使类型中的无效状态来表达无效。只支持有效值组合的类型意味着编译器会拒绝整类错误，从而产生更小、更安全的代码。</p>
<h1 id="options-和-errors"><a class="header" href="#options-和-errors">Options 和 Errors</a></h1>
<p>回到枚举的强大之处，有两个概念类型是如此常见，以至于Rust包含了内置的枚举类型来表达它们。</p>
<p>第一个概念是<code>Option</code>：要么有特定类型的值（<code>Some(T)</code>），要么没有（<code>None</code>）。对于可能不存在的值，始终使用<code>Option</code>；永远不要退回到使用标记值（-1、nullptr等）来尝试表示相同的概念。</p>
<p>然而，还有一个微妙需要考虑的地方。如果你处理的是一组集合数据，你需要考虑集合中是否存在数据与没有集合是相同的。对于大多数情况，并不需要明确区分这二者的区别，你可以直接使用Vec<Thing>：当里面不包含数据的时候就是代表没有这个集合数据。</p>
<p>当然，确实也存在其他少见的情况，需要使用Option&lt;Vec<Thing>&gt; 来区分这两种情况 —— 例如，加密系统可能需要区分“分开传输的有效载荷”和“提供了空有效载荷”。（这与SQL中的NULL标记列的争论有关。）（译者注释：相当于是编程中空是否赋予了含义）</p>
<p>一个常见的临界情况是可能不存在的字符串 - 使用 "" 还是 None 更合理来表示值的缺失？两种方式都可以，但 Option<String> 清楚地传达了这个值可能不存在的可能性。</p>
<p>第二个常见概念源自错误处理：如果一个函数失败了，该如何报告这个失败？在历史上，特殊的标记值（例如来自Linux系统调用的 -errno 返回值）或全局变量（POSIX系统的 errno）被使用。最近，支持从函数返回多个或元组返回值的语言（如Go）可能有一个约定，即在错误为非“零”时返回（结果，错误）对。</p>
<p>在Rust中，总是将可能失败的操作的结果编码为 Result&lt;T, E&gt;。T 类型保存成功的结果（在 Ok 变体中），E 类型在失败时保存错误详情（在 Err 变体中）。使用标准类型可以清晰地表达设计意图，并允许使用标准转换（条目 3）和错误处理（条目 4）；它还使得通过 ? 操作符来简化错误处理成为可能。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条目2使用类型系统来表达常见行为"><a class="header" href="#条目2使用类型系统来表达常见行为">条目2：使用类型系统来表达常见行为</a></h1>
<p><a href="Types/./Item1.html">条目 1</a> 讨论了如何使用在类型系统中表达数据结构；本条目将讨论如何使用类型系统来表达常见行为（函数）。</p>
<h1 id="方法methods"><a class="header" href="#方法methods">方法（Methods）</a></h1>
<p>首先，Rust类型系统的第一个行为就是向数据结构中添加方法：这些方法作用于某个类型的成员，由 self 标识。这种方式将相关数据和代码以面向对象的方式封装在一起，与其他语言类似；然而，在 Rust 中，方法不仅可以添加到结构类型，还可以添加到枚举类型，这与 Rust 枚举的普遍性质保持一致<a href="Types/./Item1.html">条目 1</a> 。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Shape {
    Rectangle { width: f64, height: f64 },
    Circle { radius: f64 },
}

impl Shape {
    pub fn area(&amp;self) -&gt; f64 {
        match self {
            Shape::Rectangle { width, height } =&gt; width * height,
            Shape::Circle { radius } =&gt; std::f64::consts::PI * radius * radius,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>方法的名称为它所表示的行为提供了一个标签，而方法签名为其输入和输出提供了类型信息。方法的第一个输入将是 self 的某个变体，指示该方法可能对数据结构执行的操作：</p>
<ul>
<li>&amp;self: 该参数表示方法可能读取数据结构的数据，但是并不会修改数据结构的数据内容</li>
<li>&amp;mut self: 该参数表示方法可能修改数据结构的数据内容</li>
<li>self: 该参数表示方法消耗数据结构的数据，这意味着调用者将无法再次使用数据结构（移动语意）</li>
</ul>
<h1 id="抽象行为-abstracting-behaviour"><a class="header" href="#抽象行为-abstracting-behaviour">抽象行为 （Abstracting Behaviour）</a></h1>
<p>调用一个方法总是导致执行相同的代码；从一次调用到另一次调用，变化的只是方法操作的数据。这涵盖了许多可能的场景，但如果代码需要在运行时变化怎么办？</p>
<p>Rust 在其类型系统中包含了几个特性以适应这种情况，本节将探讨这些特性。</p>
<h2 id="函数指针function-pointers"><a class="header" href="#函数指针function-pointers">（函数指针）Function Pointers</a></h2>
<p>最简单的行为抽象就是<a href="https://doc.rust-lang.org/std/primitive.fn.html">函数指针</a>: 指向（仅仅是）一些代码的指针，其类型反映了函数签名。该类型在编译时进行检查，因此到程序运行时，该值仅为一个指针的大小。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn sum(x: i32, y: i32) -&gt; i32 {
        x + y
    }
    // Explicit coercion to `fn` type is required...
    let op: fn(i32, i32) -&gt; i32 = sum;
<span class="boring">}</span></code></pre></pre>
<p>函数指针没有与之相关联的其他数据,因此它们可以通过各种方式被当作值来处理:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn sum(x: i32, y: i32) -&gt; i32 {
        x + y
    }
    // `fn` types implement `Copy`
    let op1 = op;
    let op2 = op;
    // `fn` types implement `Eq`
    assert!(op1 == op2);
    // `fn` implements `std::fmt::Pointer`, used by the {:p} format specifier.
    println!("op = {:p}", op);
    // Example output: "op = 0x101e9aeb0"
<span class="boring">}</span></code></pre></pre>
<p>需要注意的一个技术细节：需要使用显示强制类型转换为 <code>fn</code> 类型，因为仅仅使用函数名称你不会给你提供 <code>fn</code> 类型。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let op1 = sum;
    let op2 = sum;
    // Both op1 and op2 are of a type that cannot be named in user code,
    // and this internal type does not implement `Eq`.
    assert!(op1 == op2);
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">   Compiling playground v0.0.1 (/playground)
error[E0369]: binary operation `==` cannot be applied to type `fn(i32, i32) -&gt; i32 {main::sum}`
  --&gt; src/main.rs:19:18
   |
19 |     assert!(op11 == op22);
   |             ---- ^^ ---- fn(i32, i32) -&gt; i32 {main::sum}
   |             |
   |             fn(i32, i32) -&gt; i32 {main::sum}
   |
help: use parentheses to call these
   |
19 |     assert!(op11(/* i32 */, /* i32 */) == op22(/* i32 */, /* i32 */));
   |                 ++++++++++++++++++++++        ++++++++++++++++++++++

For more information about this error, try `rustc --explain E0369`.
error: could not compile `playground` (bin "playground") due to 1 previous error
</code></pre>
<p>相反,编译器错误表明该类型是类似于<code>fn(i32, i32) -&gt; i32 {main::sum}</code>的东西,这是一种完全内部的编译器类型(即无法在用户代码中编写),它不仅标识了具体的函数,还标识了它的签名。换句话说,<code>sum</code>的类型同时编码了函数的签名和它的位置(<a href="https://doc.rust-lang.org/std/primitive.fn.html#creating-function-pointers">出于优化原因</a>);但是这种类型可以自动强制转换为<code>fn</code>类型(条目 6)。</p>
<h2 id="闭包closures"><a class="header" href="#闭包closures">闭包（Closures）</a></h2>
<p>裸函数指针是有一些限制的，因为裸函数指针唯一可用的输入就是作为参数值显示传递的输入。</p>
<p>例如，考虑到使用一个函数指针来修改切片的元素：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // In real code, an `Iterator` method would be more appropriate.
    pub fn modify_all(data: &amp;mut [u32], mutator: fn(u32) -&gt; u32) {
        for value in data {
            *value = mutator(*value);
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>这个试用一些对切片简单的修改：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn modify_all(data: &amp;mut [u32], mutator: fn(u32) -&gt; u32) {
        for value in data {
            *value = mutator(*value);
        }
    }
    fn add2(v: u32) -&gt; u32 {
        v + 2
    }
    let mut data = vec![1, 2, 3];
    modify_all(&amp;mut data, add2);
    assert_eq!(data, vec![3, 4, 5,]);
<span class="boring">}</span></code></pre></pre>
<p>然而，如果我们的修改需要依赖外部的数据状态修改，这个就不太可能使用函数指针来做到这个事情。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn modify_all(data: &amp;mut [u32], mutator: fn(u32) -&gt; u32) {
        for value in data {
            *value = mutator(*value);
        }
    }
    let amount_to_add = 3;
    fn add_n(v: u32) -&gt; u32 {
        v + amount_to_add
    }
    let mut data = vec![1, 2, 3];
    modify_all(&amp;mut data, add_n);
    assert_eq!(data, vec![4, 5, 6,]);
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">   Compiling playground v0.0.1 (/playground)
error[E0434]: can't capture dynamic environment in a fn item
 --&gt; src/main.rs:9:13
  |
9 |         v + amount_to_add
  |             ^^^^^^^^^^^^^
  |
  = help: use the `|| { ... }` closure form instead

For more information about this error, try `rustc --explain E0434`.
error: could not compile `playground` (bin "playground") due to 1 previous error
</code></pre>
<p>这个错误信息表明，我们正确的选择是使用闭包来代替函数指针：闭包是一段看起来像函数定义主体的代码(一个lambda表达式),只不过:</p>
<ul>
<li>它可以作为表达式的一部分，因为可以不需要一个单独的名称来引用它</li>
<li>输入的参数使用<code>||</code>包裹，类似<code>|param1, param2|</code>(这里参数的关联类型通常可以由编译器自动推导)</li>
<li>闭包还可以捕获上下文的变量</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let amount_to_add = 3;
    let add_n = |y| {
        // a closure capturing `amount_to_add`
        y + amount_to_add
    };
    let z = add_n(5);
    assert_eq!(z, 8);
<span class="boring">}</span></code></pre></pre>
<p>为了（粗略地）理解捕获是如何进行工作的，假设编译器创建了一个一次性的内部类型，它包含lambda表达式中提到的环境上下文的所有部分。创建闭包是，会创建临时的类型来保存相关值，并且当调用闭包时，该实例将其附加在调用上下文：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let amount_to_add = 3;
    // *Rough* equivalent to a capturing closure.
    struct InternalContext&lt;'a&gt; {
        // references to captured variables
        amount_to_add: &amp;'a u32,
    }
    impl&lt;'a&gt; InternalContext&lt;'a&gt; {
        fn internal_op(&amp;self, y: u32) -&gt; u32 {
            // body of the lambda expression
            y + *self.amount_to_add
        }
    }
    let add_n = InternalContext {
        amount_to_add: &amp;amount_to_add,
    };
    let z = add_n.internal_op(5);
    assert_eq!(z, 8);
<span class="boring">}</span></code></pre></pre>
<p>这些值在上下文保存的通常是不可变引用，但是也可以作为可变引用，或者是所有权的转移。这些值的生命周期是由闭包的生命周期来决定的。（通过使用 <code>move</code> 关键字来进行所有权的移动）</p>
<p>回到我们<code>modify_all</code>的示例中，在使用函数指针的地方抱怨不能使用闭包：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn modify_all(data: &amp;mut [u32], mutator: fn(u32) -&gt; u32) {
        for value in data {
            *value = mutator(*value);
        }
    }
    let amount_to_add = 3;
    let mut data = vec![1, 2, 3];
    modify_all(&amp;mut data, |y| y + amount_to_add);
    assert_eq!(data, vec![4, 5, 6,]);
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">   Compiling playground v0.0.1 (/playground)
error[E0308]: mismatched types
 --&gt; src/main.rs:9:27
  |
9 |     modify_all(&amp;mut data, |y| y + amount_to_add);
  |     ----------            ^^^^^^^^^^^^^^^^^^^^^ expected fn pointer, found closure
  |     |
  |     arguments to this function are incorrect
  |
  = note: expected fn pointer `fn(u32) -&gt; u32`
                found closure `{closure@src/main.rs:9:27: 9:30}`
note: closures can only be coerced to `fn` types if they do not capture any variables
 --&gt; src/main.rs:9:35
  |
9 |     modify_all(&amp;mut data, |y| y + amount_to_add);
  |                                   ^^^^^^^^^^^^^ `amount_to_add` captured here
note: function defined here
 --&gt; src/main.rs:2:12
  |
2 |     pub fn modify_all(data: &amp;mut [u32], mutator: fn(u32) -&gt; u32) {
  |            ^^^^^^^^^^                   -----------------------

For more information about this error, try `rustc --explain E0308`.
error: could not compile `playground` (bin "playground") due to 1 previous error
</code></pre>
<p>相反,接收闭包的代码必须接受某个 <code>Fn*</code> trait 的实例。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn modify_all&lt;F&gt;(data: &amp;mut [u32], mut mutator: F)
    where 
        F: FnMut(u32) -&gt; u32
    {
        for value in data {
            *value = mutator(*value);
        }
    }
    let amount_to_add = 3;
    let mut data = vec![1, 2, 3];
    modify_all(&amp;mut data, |y| y + amount_to_add);
    assert_eq!(data, vec![4, 5, 6,]);
<span class="boring">}</span></code></pre></pre>
<p>Rust有三种不同的 <code>Fn*</code> trait，他们之间表达了该环境变量捕获的一些区别：</p>
<ul>
<li><code>FnOnce</code>：描述了只能调用一次的闭包，如果其环境变量的某些部分 <code>move</code> 进入闭包，那么<code>move</code>只能发生一次 - 对于原始的环境变量来说，这是一个所有权转移。所以该闭包智能被调用一次。</li>
<li><code>FnMut</code>：描述了可以多次调用的闭包，因为它是可变借用的，所以闭包可以修改其环境变量的部分。（但是不能被多个线程同时调用）</li>
<li><code>Fn</code>：描述了一个可以重复调用的闭包，并且它仅从环境中不可变地借用值。（可以被多个线程同时调用）</li>
</ul>
<p>编译器会自动为代码中的任何lambda表达式实现这些<code>Fn* trait</code>中的适当子集；不可能手动实现这些trait的任何一个（和C++的operator()重载不同）。</p>
<p>回到上面闭包的粗略的心理模型，编译器自动实现的那些trait大致对应捕获的环境上下文是否具有：</p>
<ul>
<li><code>FnOnce</code>：任何可移动的值</li>
<li><code>FnMut</code>：任何可变的引用（&amp;mut T）</li>
<li><code>Fn</code>：任何的不可变引用（&amp;T）</li>
</ul>
<p>上面列表中的后两个特征各自具有前面一个特征的特征界限，当你考虑使用闭包的时候，这是需要了解的。</p>
<ul>
<li>如果某个闭包期望调用一次（通过<code>FnOnce</code>来接收）,那么传递一个可以重复调用很多次的<code>FnMut</code>闭包也是完全可行的。</li>
<li>如果某个闭包期望调用多次（通过<code>FnMut</code>来接收）,那么传递一个不需要改变其环境变量的<code>Fn</code>闭包也是完全可行的。</li>
</ul>
<p>函数裸指针类型<code>fn</code>理论上也属于该列表的最后一个<code>Fn</code>，任何（非<code>unsafe</code>）<code>fn</code>类型会自动实现所有<code>Fn*</code> trait，因为它不从环境中借用任何内容，是符合所有<code>Fn*</code> trait的要求的。</p>
<p>因此，在编写接受闭包的代码时，请使用最通用的有效<code>Fn*</code> trait，以便于给调用者提供最大的灵活性 - 例如，接受<code>FnOnce</code>对于只调用一次的闭包。同样的建议，尽可能优选<code>Fn*</code> trait的函数bound，而不是使用裸指针函数的方式。</p>
<h1 id="特征traits"><a class="header" href="#特征traits">特征（Traits）</a></h1>
<p>Fn* 特征比裸函数指针更灵活，但它们仍然只能描述单个函数的行为，即使这样也只能根据函数的签名来描述。</p>
<p>然而，trait在Rust类型系统中是描述这种行为的另一种机制。trait定义了一些公开可用的一组相关方法。特征中的每个方法也有一个名称，提供一个标签，允许编译器消除具有相同签名的方法的歧义，更重要的是，它允许程序员推断出该方法的意图。</p>
<p>Rust trait大致类似于 Go 和 Java 中的<code>接口</code>，或者 C++ 中的<code>抽象类</code>（所有虚拟方法，没有数据成员）。trait的实现必须提供所有方法（但请注意，trait定义可以包括默认实现，条目13），并且在这些实现的使用中可以有关联数据。这意味着代码和数据以某种面向对象的方式封装在一个公共抽象中。</p>
<p>接受 <code>struct</code> 并作为参数调用其方法的代码被限制为仅适用于该特定类型。如果有多种类型实现常见行为（实现共同的trait），那么定义封装该常见行为的<code>trait</code>并让代码使用该<code>trait</code>的方法而不是特定 <code>struct</code> 上的方法会更灵活。</p>
<p>与其他面向对象的语言出现的相同类型的建议：如果预期未来的灵活性，则更喜欢接受trait类型而不是具体类型。</p>
<p>有时，您想要在类型系统中区分某些行为，但无法将其表示为trait定义中的某些特定方法签名。例如，考虑对集合进行排序的trait；实现可能是稳定的（比较相同的元素将在排序前后以相同的顺序出现），但无法在 sort 方法参数中表达这一点。</p>
<p>在这种情况下，仍然值得使用类型系统来跟踪此需求，并使用<code>marker trait</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Sort {
    /// Re-arrange contents into sorted order.
    fn sort(&amp;mut self);
}

/// Marker trait to indicate that a [`Sortable`] sorts stably.
pub trait StableSort: Sort {}
<span class="boring">}</span></code></pre></pre>
<p><code>marker trait</code>没有方法，但实现仍然必须声明它正在实现该特征 - 这充当实现者的承诺：“我郑重宣誓，我的排序实现是稳定的”。然后，依赖于稳定排序的代码可以指定 <code>StableSort</code> trait bound，依靠系统来保留其不变性。使用marker trait来区分特征方法签名中无法表达的行为。</p>
<p>一旦行为作为trait被封装到 Rust 的类型系统中，就可以通过两种方式使用它：</p>
<ul>
<li>作为<code>trait bound</code>，它限制了编译时通用数据类型或方法可接受的类型，或者</li>
<li>作为<code>trait object</code>。它限制了运行时可以存储或传递给方法的类型。</li>
</ul>
<p>条目 12 更详细地讨论了<code>trait bound</code>和<code>trait object</code>之间的权衡。</p>
<p><code>trait bound</code>指示由某种类型 T 参数化的通用代码只能在该类型 T 实现某些特定<code>trait</code>时使用。<code>trait bound</code>的存在意味着泛型的实现可以使用该特征中的方法，因为编译器将确保编译的任何 T 确实具有这些方法。这种检查发生在编译时，此时泛型是单态的（对于 C++ 的术语称为“模板实例化”）。</p>
<p>对目标类型 T 的这种限制是显式的，编码在<code>trait bound</code>中：<code>trait</code>只能由满足<code>trait bound</code>的类型实现。这与 C++ 中的等效情况形成对比，其中对 template<typename T> 中使用的类型 T 的约束是隐式的：C++ 模板代码仍然只能编译如果所有引用的方法在编译时都可用，但检查纯粹基于方法和签名。 （这种“鸭子类型”可能会导致混淆；使用 t.pop() 的 C++ 模板可能会编译为 Stack 或 Balloon – 这可能是不太理想的行为。）</p>
<p>对显式<code>trait bound</code>的需求也意味着很大一部分泛型使用<code>trait bound</code>。要了解其中的原因，观察并考虑在 T 上没有<code>trait bound</code>的情况下可以使用 struct Thing<T> 做什么。如果没有<code>trait bound</code>， Thing 只能执行适用于任何类型 T 的操作；这允许容器、集合和智能指针，但仅此而已。任何使用 T 类型的东西都需要一个<code>trait bound</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn dump_sorted&lt;T&gt;(mut collection: T)
where
    T: Sort + IntoIterator,
    T::Item: Debug,
{
    // Next line requires `T: Sort` trait bound.
    collection.sort();
    // Next line requires `T: IntoIterator` trait bound.
    for item in collection {
        // Next line requires `T::Item : Debug` trait bound
        println!("{:?}", item);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>因此，这里建议使用<code>trait bound</code>来表达对泛型中使用的类型要求，这是很容易遵循的建议 - 无论如何，编译器都会强制你遵守它。</p>
<p><code>trait object</code>是利用特征定义封装的另一种方式，但这里<code>trait</code>的不同可能实现是在运行时而不是编译时选择的。这种<code>动态分派</code>类似于 C++ 中虚拟函数的使用，并且 Rust 的底层具有与 C++ 中的大致类似的<code>vtable</code>对象。</p>
<p><code>trait object</code>的这种动态方面还意味着它们始终必须通过引用（ <code>&amp;dyn Trait</code> ）或指针（ <code>Box&lt;dyn Trait&gt;</code> ）间接处理。这是因为实现该特征的对象的大小在编译时是未知的 - 它可能是一个巨大的 <code>struct</code> 或一个很小的 ​​ <code>enum</code> - 所以没有办法正确分配的裸特征对象的内存空间。</p>
<p><code>trait object</code>的<code>trait</code>不能具有返回 <code>Self</code> 类型的方法，因为使用<code>trait object</code>的预先编译的代码不知道 <code>Self</code> 可能有多大。</p>
<p>可能存在所有不同类型的<code>T</code>，具有通用方法 fn method<T>(t:T) 的<code>trait</code>可能允许实现无数的方法。这对于用作<code>trait object</code>的<code>trait</code>来说很好，因为可能调用的泛型方法的无限集在编译时变成了实际调用的泛型方法的有限集。对于<code>trait object</code>来说情况并非如此：在编译时可用的代码必须应对在运行时出现所有可能的 T 类型。</p>
<p>这两个限制 -- 不返回 <code>Self</code> 和没有泛型方法 -- 被结合到对象安全的概念中。只有对象安全特征才能用<code>trait object</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条目-3-避免在option和result类型上使用match操作"><a class="header" href="#条目-3-避免在option和result类型上使用match操作">条目 3: 避免在Option和Result类型上使用match操作</a></h1>
<p><a href="Types/./Item1.html">条目 1</a> 阐述了<code>enum</code>的优点，并展示了如何使用<code>match</code>表达式强制程序员考虑所有可能性；这一条目探讨了在何种情况下应该避免显式地使用<code>match</code>表达式。</p>
<p><a href="Types/./Item1.html">条目 1</a> 还介绍了Rust标准库中非常常见的两个<code>enum</code>类型：</p>
<ul>
<li><code>Option&lt;T&gt;</code>：表示一个值可能存在<code>Some</code>，也可能不存在<code>None</code>。</li>
<li><code>Result&lt;T, E&gt;</code>：表示一个操作可能成功<code>Ok</code>，也可能失败<code>Err</code>。</li>
</ul>
<p>对于这些特定的<code>enum</code>类型来说，显示地使用<code>match</code>通常会导致代码更加的冗长，而且这也不符合Rust的惯用风格。</p>
<p>一种情况，当我们只关心值存在的场景，而想要直接忽略值不存在的场景，如下的代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct S {
        field: Option&lt;i32&gt;,
    }

    let s = S { field: Some(42) };
    match &amp;s.field {
        Some(i) =&gt; println!("field is {}", i),
        None =&gt; {}
    }
<span class="boring">}</span></code></pre></pre>
<p>对于这种场景来说，一个<code>if let</code>表达式更加的简洁，非常清晰：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct S {
        field: Option&lt;i32&gt;,
    }

    let s = S { field: Some(42) };
    if let Some(i) = &amp;s.field {
        println!("field is {}", i);
    }
<span class="boring">}</span></code></pre></pre>
<p>然而，大多数时候，值的缺失以及相关的错误是程序员必须处理的问题。设计软件应对失败的路径是困难的，而且其中大部分是无法通过语法解决其根本复杂性 -- 具体来说，如果失败我们应该决定接下来需要如何处理。</p>
<p>在某些情况下,正确的决策是执行一种"鸵鸟战术",明确地不处理失败的情况。使用显式的match语句来做这件事将会过于啰嗦:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let result = std::fs::File::open("/etc/passwd");
    let f = match result {
        Ok(f) =&gt; f,
        Err(_e) =&gt; panic!("Failed to open /etc/passwd!"),
    };
<span class="boring">}</span></code></pre></pre>
<p>Option和Result类型提供了<code>unwrap</code>和<code>expect</code>方法，这两个方法在值存在的情况下返回值，否则会触发panic。这两个方法是<code>match</code>的简化版本，<code>expect</code>方法允许自定义错误信息，但无论哪种情况,生成的代码都更短更简单 - 错误处理被委托给了 <code>.unwrap()</code> 后缀(但仍然存在)。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let f = std::fs::File::open("/etc/passwd").unwrap();
<span class="boring">}</span></code></pre></pre>
<p>明确一点:这些辅助函数也是会<code>panic!</code>，所以选择使用他们和选择<code>panic!</code>（条目 18）是一样的。</p>
<p>然后在很多情况下，正确的错误处理是将错误传递给调用者。这一点在编写库的时候尤为突出，因为该代码可能会在库作者无法预料的各种不同的环境中使用。为了让其他人的工作处理的更加容易一些，优先使用<code>Resutl</code>而不是<code>Option</code>，及时我们需要在不同的错误类型中进行转换（条目 4）</p>
<p><code>Result</code>类型有 <code>[#must_use]</code>属性去强制库的使用者朝着预期的方向努力 -- 如果代码未使用返回的<code>Result</code>类型忽略了它，编译器会生成警告：</p>
<pre><code class="language-shell">warning: unused `Result` that must be used
  --&gt; transform/src/main.rs:32:5
   |
32 |     f.set_len(0); // Truncate the file
   |     ^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled
</code></pre>
<p>显示使用 <code>match</code>允许一个错误进行传播，但是这里会造成冗余的样板代码（类似Go语言的错误处理方式）</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, std::io::Error&gt; {
        let f = match std::fs::File::open("/etc/passwd") {
            Ok(f) =&gt; f,
            Err(e) =&gt; return Err(e),
        };
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>减少这会冗余样板代码的关键是Rust的<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator">问号运算符?</a>。这个语法糖使得<code>Err</code>和<code>return Err(...)</code>表达式变成了一行代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, std::io::Error&gt; {
        let f = std::fs::File::open("/etc/passwd")?;
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>对于Rust新手来说，这种写法有时候会让人不安：问号运算符不太容易一眼就能注意到，因此不太容易注意到代码的实际含义以及作用。然而，即使只有一个简单的字符，类型系统仍然可以很好的工作，确保可以覆盖相关类型的表达<a href="Types/./Item1.html">条目 1</a>. - 这使得程序员可以关注到主线代码，而不用担心错误处理的细节。</p>
<p>甚者，这里相对于显示的方法调用也不会产生额外的代价，而且这些通用函数都会标记为<code>#[inline]</code>的方式，生成的代码会和显示的方法调用一样高效。</p>
<p>上述两个因素让你再选择处理<code>Option</code>和<code>Result</code>类型的时候，更倾向于使用<code>if let</code>和<code>?</code>运算符，而不是显式的<code>match</code>表达式。</p>
<p>在前面的示例中，错误类型是一致的，内部方法和外部方法使用的错误类型都是<code>std::io::Error</code>来表示错误，但是这种情况并不常见，一般来说一个函数会从一些子库中积累到不同的错误类型，而这些子库一般都是使用不同的错误类型的。</p>
<p>通常的错误映射转换会被在<a href="Types/./Item4.html">条目 4</a>中讨论，但是现在，我们就用手动的方式进行转换：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, String&gt; {
        let f = match std::fs::File::open("/etc/passwd") {
            Ok(f) =&gt; f,
            Err(e) =&gt; {
                return Err(format!("Failed to open password file: {:?}", e))
            }
        };
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>可以使用<code>.map_err()</code>转换显得更加的简洁更加符合Rust的风格。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, String&gt; {
        let f = std::fs::File::open("/etc/passwd").map_err(|e| format!("Failed to open password file: {:?}", e))?;
        // ...
    }
<span class="boring">}</span></code></pre></pre>
<p>更好的是，如果外部错误类型可以通过实现<code>From</code> trait（条目 5）来从内部类型进行创建，那么编译器就会自动转换类型，无需调用<code>.map_err()</code>。</p>
<p>这些方式的转换都是通用的，问号运算符可以说是在Rust转换<code>Option</code>和<code>Result</code>类型的大杀器，把它可以用到任何需要的地方</p>
<p>标准库提供了大量的转换函数来使得这一件事情变得很容易，详细的转换地图：下面红色的是可能发生<code>panic!</code>的方法：</p>
<p><img src="Types/./image.png" alt="" /></p>
<p><a href="https://docs.google.com/drawings/u/0/d/1EOPs0YTONo_FygWbuJGPfikO9Myt5HwtiFUHRuE1JVM/preview?pli=1">在线版本方法可点击</a></p>
<p>一个比较通用的场景，当在处理引用的时候，上面没有覆盖到。举例，考虑如下结构体：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    struct InputData {
        payload: Option&lt;Vec&lt;u8&gt;&gt;,
    }
<span class="boring">}</span></code></pre></pre>
<p>这个结构体的方法试图直接通过获取payload的引用去调用一个签名为<code>(&amp;[u8]) -&gt; Vec&lt;u8&gt;</code>加密函数，这样会失败：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl InputData {
        fn encrypt(&amp;self) -&gt; Vec&lt;u8&gt; {
            encrypt(&amp;self.payload.unwrap_or(vec![]))
        }
    }
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">error[E0507]: cannot move out of `self.payload` which is behind a shared reference
  --&gt; transform/src/main.rs:62:22
   |
62 |             encrypt(&amp;self.payload.unwrap_or(vec![]))
   |                      ^^^^^^^^^^^^ move occurs because `self.payload` has type `Option&lt;Vec&lt;u8&gt;&gt;`, which does not implement the `Copy` trait
   |
help: consider borrowing the `Option`'s content
   |
62 |             encrypt(&amp;self.payload.as_ref().unwrap_or(vec![]))
   |                                  +++++++++
</code></pre>
<p>错误信息准确描述了使代码正常工作所需要的是 Option 上的 as_ref() 方法。该方法将对 Option 的引用转换为一个内部类型引用的 Option: <code>pub const fn as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt;</code></p>
<p>总结：</p>
<ul>
<li>习惯使用<code>Option</code>和<code>Result</code>类型，优先使用<code>Result</code>;
<ul>
<li>在涉及引用的转换上，使用<code>.as_ref()</code>方法;</li>
</ul>
</li>
<li>避免显式的<code>match</code>表达式，优先使用<code>if let</code>和<code>?</code>运算符以及转换函数;</li>
<li>特别是, 使用它们在<code>?</code>运算符的作用下转换成结果类型。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条目-4-优先惯用的error类型"><a class="header" href="#条目-4-优先惯用的error类型">条目 4: 优先惯用的Error类型</a></h1>
<p><a href="Types/./Item3.html">条目 3</a>描述了如何使用标准库为<code>Option</code>和<code>Result</code>类型提供的转换方法，允许使用<code>?</code>运算符对结果类型进行简洁、方便的处理。但是并没有详细讨论如何进行类型<code>Result&lt;T, E&gt;</code>的第二个不同的错误类型之间的相互转换；这个条目将讨论这个问题。</p>
<p>这个条目只有当我们具有很多个不同的错误类型时才有意义。如果函数遇到的所有不同的错误都是同一种类型，那么直接返回该类型即可。当存在不同类型的错误时，需要决定是否应该保留子错误类型的信息。</p>
<h2 id="错误特征-error-trait"><a class="header" href="#错误特征-error-trait">错误特征 （Error Trait）</a></h2>
<p>了解标准的Trait（条目 10）是非常有必要的一件事情，这里面有一个<code>trait</code>就是<a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a>。<code>Result</code>类型的参数<code>E</code>不是必须实现<code>Error trait</code>，但是最好让你的错误类型实现<code>Error trait</code>，这样就可以允许错误类型包装器可以表达合适的<code>trait bound</code>.</p>
<p>首先需要注意的时<code>Error</code>类型的唯一硬性要求的<code>trait bound</code>:任何实现了<code>Error</code>类型还需要实现以下特征：</p>
<ul>
<li><code>Display trait</code>: 意味着它可以使用<code>{}</code>进行<code>format!</code>编辑</li>
<li><code>Debug trait</code>: 意味着它可以使用<code>{:?}</code>进行<code>format!</code>编辑</li>
</ul>
<p>换句话说，应该使用上述格式化来向用户和程序员显示<code>Error</code>类型</p>
<p><code>Error trait</code>有唯一的方法<a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.source"><code>source()</code></a>可以让<code>Error</code>类型暴露内部嵌套的内部错误。这个方法时可选的，默认的实现（条目 13）返回<code>None</code>，表示它内部的错误类型是不可用的。</p>
<p>最后需要注意的是：如果你的代码是工作在<code>no_std</code>环境中的，那么你无法实现<code>Error trait</code>，因为<code>std</code>库中的<code>Error trait</code>是<code>std</code>的一部分而不是<code>core</code>的一部分。</p>
<h2 id="最小的错误-minimal-errors"><a class="header" href="#最小的错误-minimal-errors">最小的错误 (Minimal Errors)</a></h2>
<p>如果不需要嵌套的错误信息，那么实现<code>Error</code>类型可能就是一个字符串的效果 —— 那么这样直接使用<code>String</code>类型会是比较合适的方式。也不需要比<code>String</code>实现更多的能力，所以使用<code>String</code>作为<code>E</code>类型的参数。</p>
<pre><code class="language-shell">pub fn find_user(username: &amp;str) -&gt; Resutl&lt;UserId, String&gt; {
    let f = std::fs::File::open("/etc/passwd")
        .map_err(|e| format!("Failed to open password file: {:?}", e))?;
    // ...
}
</code></pre>
<p><code>String</code>没有实现<code>Error</code>，我们更加倾向于选择<code>String</code>让上层的代码更好的处理<code>Error</code>。也不可能对<code>String</code>类型实现<code>Error</code>，因为这两个类型不满足孤儿原则。</p>
<pre><code class="language-shell">impl std::error::Error for String {}
</code></pre>
<pre><code class="language-shell">error[E0117]: only traits defined in the current crate can be implemented for
              types defined outside of the crate
  --&gt; src/main.rs:18:5
   |
18 |     impl std::error::Error for String {}
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^------
   |     |                          |
   |     |                          `String` is not defined in the current crate
   |     impl doesn't use only types from inside the current crate
   |
   = note: define and implement a trait or new type instead
</code></pre>
<p>类型别名也不能解决这种问题，因为类型别名不会创建新类型，因为编译错误也是一样的：</p>
<pre><code class="language-shell">pub type MyError = String;

impl std::error::Error for MyError {}
</code></pre>
<pre><code class="language-shell">error[E0117]: only traits defined in the current crate can be implemented for
              types defined outside of the crate
  --&gt; src/main.rs:41:5
   |
41 |     impl std::error::Error for MyError {}
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^-------
   |     |                          |
   |     |                          `String` is not defined in the current crate
   |     impl doesn't use only types from inside the current crate
   |
   = note: define and implement a trait or new type instead
</code></pre>
<p>像上面的报错一样，编译器错误信息给出了解决问题的提示，定义一个包装器类型 <code>MyError</code>（新类型模式，条目 6）允许该类型可以实现<code>Error trait</code>。(通常我们需要实现特定的trait的时候，但是两个类型不满足孤儿原则，则需要通过此手段进行trait的实现)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct MyError(String);

impl std::fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl std::error::Error for MyError {}

pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, MyError&gt; {
    let f = std::fs::File::open("/etc/passwd").map_err(|e| {
        MyError(format!("Failed to open password file: {:?}", e))
    })?;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>为了方便起见，给<code>MyError</code>类型实现<code>From&lt;String&gt;</code>特征是非常有意义的，这样便于我们从字符串转换成<code>MyError</code>类型（条目 5）</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;String&gt; for MyError {
    fn from(s: String) -&gt; Self {
        Self(s)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>当遇到<code>?</code>运算符的时候，编译器将自动转换实现了相关<code>From</code>特征的类型到目标错误类型，这将非常的方便。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_user(username: &amp;str) -&gt; Result&lt;UserId, MyError&gt; {
    let f = std::fs::File::open("/etc/passwd")
        .map_err(|e| format!("Failed to open password file: {:?}", e))?;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>上述的示例的错误路径如下：</p>
<ul>
<li><code>File::open</code>返回一个错误类型<code>std::io::Error</code>。</li>
<li><code>format!</code>实现了<code>Debug</code>特征的<code>std::io::Error</code>类型转换为一个<code>String</code>。</li>
<li><code>?</code>运算符和使得编译器可以从<code>String</code>类型转换为实现了<code>From&lt;String&gt;</code>特征的<code>MyError</code>类型。</li>
</ul>
<h2 id="嵌套错误-nested-errors"><a class="header" href="#嵌套错误-nested-errors">嵌套错误 (Nested Errors)</a></h2>
<p>另一种时嵌套错误内容很重要，需要保留它并提供给调用者。</p>
<p>考虑一个库函数，它尝试以字符串(String)的方式返回一个文件的第一行不太长的内容，稍微思考一下，也有可能会发生如下三种类型的故障：</p>
<ul>
<li>该文件可能不存在或者无法读取</li>
<li>该文件可能包含无效的UTF-8数据，因为无法转换为<code>String</code></li>
<li>该文件的第一行可能太长</li>
</ul>
<p>根据<a href="Types/./Item1.html">条目 1</a>，你可以使用类型系统将所有可能性表达为<code>enum</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub enum MyError {
    Io(std::io::Error),
    Utf8(std::string::FromUtf8Error),
    General(String),
}
<span class="boring">}</span></code></pre></pre>
<p>此 enum 定义包含 derive(Debug) ，但为了满足 Error 特征，还需要 Display 实现：</p>
<pre><code class="language-shell">impl std::fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            MyError::Io(e) =&gt; write!(f, "I/O error: {}", e),
            MyError::Utf8(e) =&gt; write!(f, "UTF-8 error: {}", e),
            MyError::General(e) =&gt; write!(f, "General error: {}", e),
        }
    }
}
</code></pre>
<p>覆写默认的<code>source()</code>实现也很有意义，以便轻松访问嵌套类型的错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::error::Error;

impl Error for MyError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        match self {
            MyError::Io(e) =&gt; Some(e),
            MyError::Utf8(e) =&gt; Some(e),
            MyError::General(_) =&gt; None,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>使用<code>enum</code>可以使错误处理变得简洁同时保留不同错误类型的信息：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::BufRead; // for `.read_until()`

/// Maximum supported line length.
const MAX_LEN: usize = 1024;

/// Return the first line of the given file.
pub fn first_line(filename: &amp;str) -&gt; Result&lt;String, MyError&gt; {
    let file = std::fs::File::open(filename).map_err(MyError::Io)?;
    let mut reader = std::io::BufReader::new(file);

    // (A real implementation could just use `reader.read_line()`)
    let mut buf = vec![];
    let len = reader.read_until(b'\n', &amp;mut buf).map_err(MyError::Io)?;
    let result = String::from_utf8(buf).map_err(MyError::Utf8)?;
    if result.len() &gt; MAX_LEN {
        return Err(MyError::General(format!("Line too long: {}", len)));
    }
    Ok(result)
}
<span class="boring">}</span></code></pre></pre>
<p>为所有子错误类型实现<code>From</code>特征是非常有意义的，这样可以使得错误处理更加简洁：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;std::io::Error&gt; for MyError {
    fn from(e: std::io::Error) -&gt; Self {
        Self::Io(e)
    }
}
impl From&lt;std::string::FromUtf8Error&gt; for MyError {
    fn from(e: std::string::FromUtf8Error) -&gt; Self {
        Self::Utf8(e)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这个可以防止库使用者受到孤儿规则的限制，不允许他们在<code>MyError</code>上实现 <code>From</code> trait。因为对于 <code>From</code> trait和<code>MyError</code>对于库使用者来说都是外部的类型。</p>
<p>最好的是实现<code>From</code> trait可以让这个过程更加的简洁，因为问号运算符可以自动将实现了<code>From</code> trait的错误类型转换为<code>MyError</code>类型。从而不需要<code>map_err</code>来处理错误。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::BufRead; // for `.read_until()`

/// Maximum supported line length.
pub const MAX_LEN: usize = 1024;

/// Return the first line of the given file.
pub fn first_line(filename: &amp;str) -&gt; Result&lt;String, MyError&gt; {
    let file = std::fs::File::open(filename)?; // `From&lt;std::io::Error&gt;`
    let mut reader = std::io::BufReader::new(file);
    let mut buf = vec![];
    let len = reader.read_until(b'\n', &amp;mut buf)?; // `From&lt;std::io::Error&gt;`
    let result = String::from_utf8(buf)?; // `From&lt;string::FromUtf8Error&gt;`
    if result.len() &gt; MAX_LEN {
        return Err(MyError::General(format!("Line too long: {}", len)));
    }
    Ok(result)
}
<span class="boring">}</span></code></pre></pre>
<p>编写完整的错误类型可能涉及很多的样板代码，这使得通过<code>derive</code>宏来自动化是实现是非常好的实践（条目 28）。然而，没有必要自己编写这样的宏，考虑使用David Tolnay的<code>thiserror</code>库，它提供了这个类高质量以及广泛的使用的宏。<code>thiserror</code>生成的代码还小心地避免了<code>thiserror</code>类型在生成式API中可见性，反过来讲，这样将对于（条目 24）的问题会不太适用。</p>
<h2 id="trait对象-trait-objects"><a class="header" href="#trait对象-trait-objects">trait对象 (Trait Objects)</a></h2>
<p>第一种处理嵌套错误的方法丢弃了所有子错误的详细信息，只保留了一些字符串输出（即format!("{:?}", err)）。第二种方法保留了所有可能子错误的完整类型信息，但需要完全枚举所有可能的子错误类型。</p>
<p>这里有一个问题，是否有一种折中的方法，既能保留子错误信息，又不需要手动包括每一种可能的错误类型？</p>
<p>将子错误信息编码为<a href="https://doc.rust-lang.org/reference/types/trait-object.html">trait对象</a>避免了为每种错误创建枚举变体的需要，抹去了特定底层错误类型的细节。接收这种对象的人将能够访问<code>Error trait</code>及其<code>trait bounds</code>的方法 -- <code>source()</code>、<code>Display::fmt()</code> 和 <code>Debug::fmt()</code>，但不需要知道子错误的原始静态类型。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub enum WrappedError {
    Wrapped(Box&lt;dyn Error&gt;),
    General(String),
}

impl std::fmt::Display for WrappedError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            Self::Wrapped(e) =&gt; write!(f, "Inner error: {}", e),
            Self::General(s) =&gt; write!(f, "{}", s),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>事实证明这是可能的，但这种方式出奇的微妙。部分难度来自于<code>trait object</code>的对象安全性约束（条目 12），这里Rust的一致性规则起到了作用，这些规则大致说的是一个类型最多可以实现一次<code>trait</code>。</p>
<p>假设有一个错误包装类型<code>WrappedError</code>通常会实现如下两个功能：</p>
<ul>
<li>实现<code>Error trait</code>, 因为它本身也是一个错误类型。</li>
<li>实现<code>From</code> trait，以便将任何实现了<code>Error trait</code>的子类型转换为<code>WrappedError</code>。</li>
</ul>
<p>因为<code>WrappedError</code>实现了<code>Error trait</code>，这个意味着<code>WrappedError</code>类型可以通过<code>From</code>实现自我转换，这样就与<code>From trait</code>的全面自反实现冲突。</p>
<pre><code class="language-shell">impl Error for WrappedError {}

impl&lt;E: 'static + Error&gt; From&lt;E&gt; for WrappedError {
    fn from(e: E) -&gt; Self {
        Self::Wrapped(Box::new(e))
    }
}
</code></pre>
<pre><code class="language-shell">error[E0119]: conflicting implementations of trait `From&lt;WrappedError&gt;` for
              type `WrappedError`
   --&gt; src/main.rs:279:5
    |
279 |     impl&lt;E: 'static + Error&gt; From&lt;E&gt; for WrappedError {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: conflicting implementation in crate `core`:
            - impl&lt;T&gt; From&lt;T&gt; for T;
</code></pre>
<p>David Tolnay 的 <a href="https://docs.rs/anyhow">anyhow</a> 是一个已经解决了这些问题的 crate（通过通过 <a href="https://github.com/dtolnay/anyhow/issues/63#issuecomment-582079114"><code>Box</code> 添加一个额外的间接层</a>），并且还添加了其他有用的功能（如堆栈跟踪）。因此，它正迅速成为错误处理的标准推荐——这里也再次推荐：考虑在应用程序中使用 anyhow crate 进行错误处理。</p>
<h2 id="库与应用libraries-versus-applications"><a class="header" href="#库与应用libraries-versus-applications">库与应用（Libraries Versus Applications）</a></h2>
<p>前一部分的最终建议中包括了一个限定词"...用于应用程序中的错误处理"。这是因为通常区分为库重用编写的代码和构成顶层应用程序的代码之间存在明显的差异。</p>
<p>为库编写的代码无法预测代码使用的环境，因此最好发出具体、详细的错误信息，并让调用者自行决定如何使用这些信息。这倾向于之前描述的枚举式嵌套错误（同时也避免了在库的公共 API 中依赖 anyhow，见条目 24）。</p>
<p>然而，应用程序代码通常需要更多地关注如何向用户展示错误。它还可能需要处理其依赖关系图中所有库发出的所有不同错误类型（见条目 25）。因此，一个更动态的错误类型（如 <a href="https://docs.rs/anyhow/latest/anyhow/struct.Error.html">anyhow::Error</a>）使得错误处理在整个应用程序中更简单、更一致。</p>
<h2 id="牢记于心的事情things-to-remember"><a class="header" href="#牢记于心的事情things-to-remember">牢记于心的事情（Things to Remember）</a></h2>
<ul>
<li>标准的<code>Error trait</code>对你来说不常用，建议你为你的错误类型实现<code>Error trait</code>。</li>
<li>在处理异构的底层错误类型时，需要决定是否有必要保留这些类型。
<ul>
<li>如果不需要保留，则考虑适用<code>anyhow</code>去封装你应用的子错误类型。</li>
<li>如果需要保留，则考虑适用<code>enum</code>去封装你应用的子错误类型。考虑适用<code>thiserror</code>去更好的帮助你这么做。</li>
</ul>
</li>
<li>考虑适用<code>anyhow</code>库在你的应用程序代码中进行错误处理。</li>
<li>如果你想自己决定，无论怎么决定，都将错误类型编码到类型系统中(<a href="Types/./Item1.html">条目 1</a>)。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条目-5了解类型转换"><a class="header" href="#条目-5了解类型转换">条目 5：了解类型转换</a></h1>
<p>Rust类型转换分为三类：</p>
<ul>
<li>手动：用户通过<code>From</code>和<code>Into</code> trait来实现类型转换。</li>
<li>半自动：适用<code>as</code>关键字在值类型之间进行转换。</li>
<li>自动：隐式强制转换为新类型。</li>
</ul>
<p>这个条目主要介绍第一点因为后两者的转换不适用于用户自定义类型的转换，对此有一些例外，因为本条目末尾的部分会讨论强制转换和，包括它们如何应用与用户自定义类型。</p>
<p>需要注意的是，在Rust中和其他语言不通，默认不会进行数字类型之间的自动转换。哪怕是整数类型的安全转换也不允许自动转换。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = 2;
let y: u64 = x;
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src/main.rs:70:18
   |
70 |     let y: u64 = x;
   |            ---   ^ expected `u64`, found `u32`
   |            |
   |            expected due to this
   |
help: you can convert a `u32` to a `u64`
   |
70 |     let y: u64 = x.into();
   |                   +++++++
</code></pre>
<h2 id="用户定义的类型转换"><a class="header" href="#用户定义的类型转换">用户定义的类型转换</a></h2>
<p>与该语言的其他功能一直（条目 10），在不同用户自定义类型之间进行转换的能力被封装为标准<code>trait</code>,或者更加确切的讲，封装为一组相关的通用<code>trait</code>。</p>
<p>表达转换类型值的能力的四个相关的<code>trait</code>:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>Frome&lt;T&gt;</code></a>: 从类型<code>T</code>到此类型的转换。而且转换总是会成功。</li>
<li><a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom&lt;T&gt;</code></a>: 从类型<code>T</code>到此类型的转换。转换可能会失败。</li>
<li><a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into&lt;T&gt;</code></a>: 从此类型到类型<code>T</code>的转换。而且转换总是会成功。</li>
<li><a href="https://doc.rust-lang.org/std/convert/trait.TryInto.html"><code>TryInto&lt;T&gt;</code></a>: 从此类型到类型<code>T</code>的转换。转换可能会失败。</li>
</ul>
<p>在<a href="Types/./Item1.html">条目 1</a>中我们讨论过适用类型系统来表达数据结构。不难发现<code>Try...</code>变体的区别对于<code>trait</code>唯一的方法来说返回的是一个<code>Result</code>而不是保障一定有一个新的转换类型。<code>Try..</code> trait定义还包含一个关联类型，需要给出当失败时候应该返回的错误类型E。</p>
<p>因此，在这里有第一条建议，如果我们的转换可能失败，则实现<code>Try...</code> trait,与<a href="Types/./Item4.html">条目 4</a>一致。另一种方式是直接使用<code>.unwarp()</code>方法来忽略可能的错误，但是这样做必须经过深思熟虑，而且最好大多数情况把这个决定权交给调用者。</p>
<p>类型转换trait具有明显的对称性：如果类型<code>T</code>可以转换为<code>U</code>(通过<code>Into&lt;U&gt;</code>),那么<code>U</code>可以转换为<code>T</code>(通过<code>From&lt;T&gt;</code>)。</p>
<p>情况确实如此，这就引出第二条建议：实现<code>From</code> trait。Rust标准库必须让实现者选择两个中一个trait来实现，以防止迷人眼，所以标准库根据<code>From</code> trait的实现自动提供了<code>Into</code> trait的实现。</p>
<p>如果你在自己的泛型类型上使用这两个特质之一作为特征约束（trait bounds），那么建议你反过来：使用 Into 特征作为特征约束（trait bounds）。这样，既可以满足直接实现 Into 的对象，也可以满足仅直接实现 From 的对象。</p>
<p>这种自动由 From 和 Into的转换在文档中有说明，但也非常值得阅读标准库代码中的相关部分，那里包含了一个全覆盖的特征（trait）实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, U&gt; Into&lt;U&gt; for T 
where 
    U: From&lt;T&gt; 
{
    fn into(self) -&gt; U {
        U::from(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>将特征规范翻译成大白话有利于帮助我们理解复杂的特征约束，在这个案例中，可以简单的描述为：当类型<code>U</code>实现了<code>From&lt;T&gt;</code>，那么就为类型<code>T</code>实现<code>Into&lt;U&gt;</code>。</p>
<p>标准库类型包括了这些转换特征的各种实现。正如你所期望的，对于目标类型包含源类型所有可能值的整数转换有 From 实现（例如，<code>From&lt;u32&gt;</code> for <code>u64</code>），当源可能不适合目标时有 TryFrom 实现（例如，<code>TryFrom&lt;u64&gt;</code> for <code>u32</code>）。</p>
<p>除了之前展示的 <code>Into</code> 特征的实现之外，还有其他各种全覆盖的特征实现；这些主要是针对智能指针类型，允许智能指针从其持有的类型实例自动构建。这意味着接受智能指针参数的泛型方法也可以用普通旧项目调用；关于这一点更多讨论，会在条目 8中详述。</p>
<p><code>TryFrom</code> 特征也为任何自动实现（如前所示）了 <code>From</code> 的任何类型已经在相反方向上实现了 <code>Into</code> 特征的类型提供了全覆盖实现 -- 换句话说，如果你可以无误地将 <code>T</code> 转换为 <code>U</code>，你也可以可靠地从 <code>T</code> 获得 <code>U</code>；由于这种转换总是会成功，相关的错误类型被命名为 <a href="https://doc.rust-lang.org/std/convert/enum.Infallible.html">Infallible</a>。</p>
<p>还有一个非常特殊的 <code>From</code> 泛型实现，那就是 <em>反射实现</em>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; From&lt;T&gt; for T {
    fn from(t: T) -&gt; T {
        t
    }
}
<span class="boring">}</span></code></pre></pre>
<p>用大白话表达，这在讲“给定一个 <code>T</code>，我可以得到一个 <code>T</code>。”这是显而易见的“嗯，当然”，值得我们停下来思考为什么这个实现会有用。</p>
<p>考虑一个简单的新类型<code>struct</code>(条目 6)，并且有一个函数会操作它（忽略这个函数可以表达为一个类方法）：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Integer value from an IANA-controlled range.
#[derive(Clone, Copy, Debug)]
pub struct IanaAllocated(pub u64);

/// Indicate whether value is reserved.
pub fn is_iana_reserved(s: IanaAllocated) -&gt; bool {
    s.0 == 0 || s.0 == 65535
}
<span class="boring">}</span></code></pre></pre>
<p>这个函数可以适用这个类的实例进行调用:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = IanaAllocated(1);
println!("{:?} reserved? {}", s, is_iana_reserved(s));
// output: "IanaAllocated(1) reserved? false"
<span class="boring">}</span></code></pre></pre>
<p>但即使为新类型封装实现了 <code>From&lt;u64&gt;</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;u64&gt; for IanaAllocated {
    fn from(v: u64) -&gt; Self {
        Self(v)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这个函数不能通过 <code>u64</code> 直接调用：</p>
<pre><code class="language-shell">if is_iana_reserved(42) {
    // ...
}
</code></pre>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src/main.rs:77:25
   |
77 |     if is_iana_reserved(42) {
   |        ---------------- ^^ expected `IanaAllocated`, found integer
   |        |
   |        arguments to this function are incorrect
   |
note: function defined here
  --&gt; src/main.rs:7:8
   |
7  | pub fn is_iana_reserved(s: IanaAllocated) -&gt; bool {
   |        ^^^^^^^^^^^^^^^^ ----------------
help: try wrapping the expression in `IanaAllocated`
   |
77 |     if is_iana_reserved(IanaAllocated(42)) {
   |                         ++++++++++++++  +
</code></pre>
<p>然而，一个泛型函数版本接受（并明确转换）任何满足         <code>Into&lt;IanaAllocated&gt;</code> 的类型：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is_iana_reserved&lt;T&gt;(s: T) -&gt; bool
where
    T: Into&lt;IanaAllocated&gt;,
{
    let s = s.into();
    s.0 == 0 || s.0 == 65535
}
<span class="boring">}</span></code></pre></pre>
<p>才允许这样使用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if is_iana_reserved(42) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>有了这个特征约束，<code>From&lt;T&gt;</code> 的反射特征实现更有意义了：它意味着泛型函数可以处理已经是 <code>IanaAllocated</code> 实例的项目，无需转换。(译者注：目前还未吃透该概念，需要进一步的学习)</p>
<p>这种模式还解释了为什么（以及如何）Rust 代码有时似乎在类型之间进行隐式转换：<code>From&lt;T&gt;</code> 的实现和 <code>Into&lt;T&gt;</code> 的特征约束的组合导致代码看起来在调用点神奇地转换（但仍然在底层进行安全、明确的转换）。当这种模式与引用类型及其相关的转换特征结合时，它变得更加强大；更多内容见条目 8。</p>
<h2 id="显示强制转换casts"><a class="header" href="#显示强制转换casts">显示强制转换（Casts）</a></h2>
<p>Rust还有一个<code>as</code>关键字去执行类型之间显示的<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions">转换</a>。</p>
<p>这些类型之间的类型构成了一个相当有限的集合，包括标准库基础的整数类型(也提供了可选的<code>into</code>方法转换)，以及用户自定义的简单<code>enum</code>类型(仅仅是关联了整数值的类型)。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = 9;
let y = x as u64;
let z: u64 = x.into();
<span class="boring">}</span></code></pre></pre>
<p><code>as</code>转换还允许有损失的转换：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u32 = 9;
let y = x as u16;
<span class="boring">}</span></code></pre></pre>
<p>这种转换会被<code>from</code>和<code>into</code>方法拒绝：</p>
<pre><code class="language-text">error[E0277]: the trait bound `u16: From&lt;u32&gt;` is not satisfied
   --&gt; src/main.rs:136:20
    |
136 |     let y: u16 = x.into();
    |                    ^^^^ the trait `From&lt;u32&gt;` is not implemented for `u16`
    |
    = help: the following other types implement trait `From&lt;T&gt;`:
              &lt;u16 as From&lt;NonZeroU16&gt;&gt;
              &lt;u16 as From&lt;bool&gt;&gt;
              &lt;u16 as From&lt;u8&gt;&gt;
    = note: required for `u32` to implement `Into&lt;u16&gt;`
</code></pre>
<p>为了一致性和安全性，你应该优先适用<code>from</code>和<code>into</code>方法，而不是<code>as</code>转换，除非你理解更加精确的<a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#semantics">转换语意</a>（例如，为了和C之间的互相操作性）。这个建议可以通过<code>Clippy</code>工具进一步强化（条目 29），其中包括一些关于<a href="https://rust-lang.github.io/rust-clippy/stable/index.html#/as_conversions"><code>as</code>转换</a>的lints;但是在默认情况下这些lint是关闭的。</p>
<h2 id="隐式强制转换coercion"><a class="header" href="#隐式强制转换coercion">隐式强制转换（Coercion）</a></h2>
<p>前一节描述的显式 <code>as</code> 转换是编译器将默默执行的隐式强制转换的超集：任何隐式强制转换都可以通过显式的 <code>as</code> 来显示强制转换，但反之则不成立。特别是，前一节进行的整数转换不是隐式强制转换，因此总是需要使用 <code>as</code>。</p>
<p>大多数隐式强制转换涉及指针和引用类型的无声转换，这些转换对程序员来说是合理且方便的，类似的转换有：</p>
<ul>
<li>从一个可变引用到一个不可变引用。（一个接受<code>&amp;T</code>类型的函数可以使用一个<code>&amp;mut T</code>的类型来作为的参数）</li>
<li>一个引用到一个原生指针（这不是<code>unsafe</code>的 -- 其实不安全的行为是发生在你无知的对一个原生指针进行解引用的时候）</li>
<li>一个没有捕获任何变量的闭包到一个函数指针（<a href="Types/./Item2.html">条目 2</a>）</li>
<li>一个<a href="https://doc.rust-lang.org/std/primitive.array.html">数组</a>到一个<a href="https://doc.rust-lang.org/std/primitive.slice.html">切片</a></li>
<li>一个实现了trait的具体类型到该<a href="https://doc.rust-lang.org/reference/types/trait-object.html">trait对象</a></li>
<li>一个从厂生命周期到短生命周期（条目 14）</li>
</ul>
<p>只有两种隐式强制转换的行为会受到用户定义类型的影响。第一种情况发生在用户定义的类型实现了 <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a> 或 <a href="https://doc.rust-lang.org/std/ops/trait.DerefMut.html"><code>DerefMut</code></a> 特征时。这些特征表明用户定义的类型在某种程度上充当智能指针（见条目 8），在这种情况下，编译器将强制将对智能指针项的引用转换为对智能指针所包含的类型项的引用（由其特征的 <a href="https://doc.rust-lang.org/std/ops/trait.Deref.html#associatedtype.Target"><code>Target</code></a>关联类型指定）。</p>
<p>第二种用户定义类型的隐式强制转换发生在将具体对象转换为特征对象时。这个操作构建了一个具体对象的胖指针；之所以称为胖指针，是因为它包括了具体对象在内存中位置的指针和指向具体类型实现特征的虚表的指针 -- 见条目 8。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条目-6-拥抱新类型"><a class="header" href="#条目-6-拥抱新类型">条目 6: 拥抱新类型</a></h1>
<p><a href="Types/./Item1.html">条目 1</a>描述了元组结构体（tuple structs），元组结构体中没有命名字段而是通过数字来进行引用访问(self.0)。这个条目着重于有已经存在的类型单个类型的元组结构体，从而创建一个新类型，该类型可以保存于封装完全相同的值范围。这种模式在Rust中非常普遍，它非常值得我们在单一的条目中进行讨论，而且可以有一个自己的名字：newtype模式。</p>
<p>newtype模式最简单的用途是为类型指示超出其正常行为的<a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction">附加语意</a>.为了说明这一点，想象一个将一个卫星发送到火星的项目。这是一个非常大的项目，因此不同的团队构建了该项目的不同部分，一组处理火箭发动机的代码：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Fire the thrusters. Returns generated impulse in pound-force seconds.
pub fn thruster_impulse(direction: Direction) -&gt; f64 {
    // ...
    return 42.0;
}
<span class="boring">}</span></code></pre></pre>
<p>而另一组负责惯性导航系统：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Update trajectory model for impulse, provided in Newton seconds.
pub fn update_trajectory(force: f64) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>最终这些不同的部分需要连接在一起：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thruster_force: f64 = thruster_impulse(direction);
let new_direction = update_trajectory(thruster_force);
<span class="boring">}</span></code></pre></pre>
<p>糟糕 <a href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure">Mars Climate Orbiter</a></p>
<p>Rust还包含类型别名特性，它允许不同的组可以清晰地表达自己的意图：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Units for force.
pub type PoundForceSeconds = f64;

/// Fire the thrusters. Returns generated impulse.
pub fn thruster_impulse(direction: Direction) -&gt; PoundForceSeconds {
    // ...
    return 42.0;
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Units for force.
pub type NewtonSeconds = f64;

/// Update trajectory model for impulse.
pub fn update_trajectory(force: NewtonSeconds) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>然而，类型别名只是字面上的约束，它们是比以前版本的文档主食更强的提示，但是并没有直接阻止在需要使用<code>NewtonSeconds</code>值的地方传递<code>PoundForceSeconds</code>值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thruster_force: PoundForceSeconds = thruster_impulse(direction);
let new_direction = update_trajectory(thruster_force);
<span class="boring">}</span></code></pre></pre>
<p>哦不（不知道如何翻译）</p>
<p>从这里引出就是我们newtype模式的用武之地了：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Units for force.
pub struct PoundForceSeconds(pub f64);

/// Fire the thrusters. Returns generated impulse.
pub fn thruster_impulse(direction: Direction) -&gt; PoundForceSeconds {
    // ...
    return PoundForceSeconds(42.0);
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Units for force.
pub struct NewtonSeconds(pub f64);

/// Update trajectory model for impulse.
pub fn update_trajectory(force: NewtonSeconds) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>顾名思义，newtype是一种新类型，因此当类型不匹配时候，编译器直接会进行拦截，这里尝试将<code>PoundForceSeconds</code>传递给需要 <code>NewtonSeconds</code>的地方会导致编译错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thruster_force: PoundForceSeconds = thruster_impulse(direction);
let new_direction = update_trajectory(thruster_force);
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">error[E0308]: mismatched types
  --&gt; src/main.rs:76:43
   |
76 |     let new_direction = update_trajectory(thruster_force);
   |                         ----------------- ^^^^^^^^^^^^^^ expected
   |                         |        `NewtonSeconds`, found `PoundForceSeconds`
   |                         |
   |                         arguments to this function are incorrect
   |
note: function defined here
  --&gt; src/main.rs:66:8
   |
66 | pub fn update_trajectory(force: NewtonSeconds) {
   |        ^^^^^^^^^^^^^^^^^ --------------------
help: call `Into::into` on this expression to convert `PoundForceSeconds` into
      `NewtonSeconds`
   |
76 |     let new_direction = update_trajectory(thruster_force.into());
   |                                                         +++++++
</code></pre>
<p>根据<a href="Types/./Item5.html">条目 5</a>的描述，我们给<code>NewtonSeconds</code>类型添加标准的<code>From</code>特征的实现</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;PoundForceSeconds&gt; for NewtonSeconds {
    fn from(val: PoundForceSeconds) -&gt; NewtonSeconds {
        NewtonSeconds(4.448222 * val.0)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这样我们就允许使用<code>.into()</code>方法进行类型的转换：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let thruster_force: PoundForceSeconds = thruster_impulse(direction);
let new_direction = update_trajectory(thruster_force.into());
<span class="boring">}</span></code></pre></pre>
<p>使用新类型来标记类型的附加单位语意可以帮助使布尔参数不那么容易混淆。重新审视<a href="Types/./Item1.html">条目 1</a>中的示例，使用newtype模式使参数的意图更加明确：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DoubleSided(pub bool);

struct ColorOutput(pub bool);

fn print_page(sides: DoubleSided, color: ColorOutput) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print_page(DoubleSided(true), ColorOutput(false));
<span class="boring">}</span></code></pre></pre>
<p>如果需要考虑大小效率以及二进制兼容性，则可以使用<code>repr(transparent)</code>属性可确保新类型在内存中具有与内部类型相同的表示形式。</p>
<p>这就是newtype模式的简单用法，也是<a href="Types/./Item1.html">条目 1</a>的具体示例 -- 将语意编码到类型系统中，方便编译器负责管理这些语意，避免程序员犯错。</p>
<h2 id="绕过特征的孤儿规则"><a class="header" href="#绕过特征的孤儿规则">绕过特征的孤儿规则</a></h2>
<p>另一个常见但是更加微妙的需要newtype模式的场景是围绕着Rust的孤儿规则的。粗略地讲，这表示只有满足如下条件之一，crate才能实现一个trait：</p>
<ul>
<li>crate已经定义了这个trait</li>
<li>crate有需要实现trait的这个类型</li>
</ul>
<p>尝试为外来类型实现外来特征：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

impl fmt::Display for rand::rngs::StdRng {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; Result&lt;(), fmt::Error&gt; {
        write!(f, "&lt;StdRng instance&gt;")
    }
}
<span class="boring">}</span></code></pre></pre>
<p>会导致编译器报错（这反过来又需要newtype模式来解决）</p>
<pre><code class="language-shell">error[E0117]: only traits defined in the current crate can be implemented for
              types defined outside of the crate
   --&gt; src/main.rs:146:1
    |
146 | impl fmt::Display for rand::rngs::StdRng {
    | ^^^^^^^^^^^^^^^^^^^^^^------------------
    | |                     |
    | |                     `StdRng` is not defined in the current crate
    | impl doesn't use only types from inside the current crate
    |
    = note: define and implement a trait or new type instead
</code></pre>
<p>这种限制的原因是由于存在有歧义的风险：如果依赖图中的两个不同的crate(条目 25)都有<code>impl std::fmt::Display for rand::rngs::StdRng</code>，那么编译器/链接器就无法在两者之间进行选择。</p>
<p>这样经常导致编译的冲突和挫败感，例如，如果你尝试给来自另外一个crate的类型实现<code>serialize data</code>，孤儿元组则会阻止你编写<code>impl serde::Serialize for somecrate::SomeType</code></p>
<p>但是newtype模式意味着你正在定义一个新类型，它就是当前crate的一部分，因此就可以满足孤儿原则的第二个条件，现在就可以实现外部的trait：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyRng(rand::rngs::StdRng);

impl fmt::Display for MyRng {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; Result&lt;(), fmt::Error&gt; {
        write!(f, "&lt;MyRng instance&gt;")
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="newtype的限制"><a class="header" href="#newtype的限制">newtype的限制</a></h2>
<p>newtype模式解决了上述两类问题 -- 防止了单位相同类型的转换和绕过孤儿规则 -- 但是它也带来了一些尴尬：涉及newtype的每个操作都需要转发到其内部类型。</p>
<p>简单的考虑就意味着代码必须使用<code>thing.0</code>,而不是<code>thing</code>，这个很简单，编译器会告诉你哪里需要这么做。</p>
<p>更尴尬的是是内部类型上的任何特征实现都丢失了，因为newtype是一个新类型，所以现有的内部实现都不得适用。</p>
<p>对于可派生特征，这仅意味着newtype需要声明<code>derive</code>属性：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct NewType(InnerType);
<span class="boring">}</span></code></pre></pre>
<p>然而对于更加复杂的特征来说，需要一些转发样板来恢复内部类型的实现，例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
impl fmt::Display for NewType {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; Result&lt;(), fmt::Error&gt; {
        self.0.fmt(f)
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条目-7-使用builders来构建复杂的类型"><a class="header" href="#条目-7-使用builders来构建复杂的类型">条目 7: 使用Builders来构建复杂的类型</a></h1>
<p>这个条目描述了构建者模式，其中复杂的数据结构有一个相关的构建者类型，使用户更容易创建数据结构的实例。</p>
<p>Rust 强调在创建结构体的新实例时，结构体中的所有字段都必须被填充。这通过确保没有未初始化的值来保持代码的安全性，但也导致了比理想情况更多的冗长样板代码。</p>
<p>例如，任何可选字段都必须明确标记为缺失，使用 None：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Phone number in E164 format.
#[derive(Debug, Clone)]
pub struct PhoneNumberE164(pub String);

#[derive(Debug, Default)]
pub struct Details {
    pub given_name: String,
    pub preferred_name: Option&lt;String&gt;,
    pub middle_name: Option&lt;String&gt;,
    pub family_name: String,
    pub mobile_phone: Option&lt;PhoneNumberE164&gt;,
}

// ...

let dizzy = Details {
    given_name: "Dizzy".to_owned(),
    preferred_name: None,
    middle_name: None,
    family_name: "Mixer".to_owned(),
    mobile_phone: None,
};
<span class="boring">}</span></code></pre></pre>
<p>这种样例代码也很脆弱，因为将来如果在结构体中添加一个新字段，就需要更新每一个构建该结构体的地方。</p>
<p>这个样例中可以通过实现<a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>特征来减少代码的冗余度，就像<a href="Types/../Traits/Item10.html">条目10</a>描述的一样。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let dizzy = Details {
    given_name: "Dizzy".to_owned(),
    family_name: "Mixer".to_owned(),
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<p>使用 <code>Default</code> 也有助于减少在添加新字段时所需的更改，前提是新字段本身的类型实现了 <code>Default</code>。</p>
<p>这是一个更普遍的问题：自动派生的 <code>Default</code> 实现只有在所有字段类型都实现了 <code>Default</code> trait 时才有效。如果有一个字段不符合要求，派生步骤就不起作用：</p>
<p>下面的例子是无法编译的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Default)]
pub struct Details {
    pub given_name: String,
    pub preferred_name: Option&lt;String&gt;,
    pub middle_name: Option&lt;String&gt;,
    pub family_name: String,
    pub mobile_phone: Option&lt;PhoneNumberE164&gt;,
    pub date_of_birth: time::Date,
    pub last_seen: Option&lt;time::OffsetDateTime&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>编译器错误：</p>
<pre><code class="language-shell">error[E0277]: the trait bound `Date: Default` is not satisfied
  --&gt; src/main.rs:48:9
   |
41 |     #[derive(Debug, Default)]
   |                     ------- in this derive macro expansion
...
48 |         pub date_of_birth: time::Date,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Default` is not
   |                                       implemented for `Date`
   |
   = note: this error originates in the derive macro `Default`
</code></pre>
<p>由于孤儿规则，代码不能为 <code>chrono::Utc</code> 实现 <code>Default</code>；但即便可以，这也不会有帮助——使用默认的出生日期值几乎总是错误的。</p>
<p>缺少 <code>Default</code> 意味着所有字段都必须手动填写：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bob = Details {
    given_name: "Robert".to_owned(),
    preferred_name: Some("Bob".to_owned()),
    middle_name: Some("the".to_owned()),
    family_name: "Builder".to_owned(),
    mobile_phone: None,
    date_of_birth: time::Date::from_calendar_date(
        1998,
        time::Month::November,
        28,
    )
    .unwrap(),
    last_seen: None,
};
<span class="boring">}</span></code></pre></pre>
<p>如果为复杂的数据结构实现构建者模式，这些易用性可以得到改善。</p>
<p>构建者模式的最简单变体是一个单独的结构体，它保存构建项目所需的信息。为简单起见，示例将保存项目本身的一个实例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DetailsBuilder(Details);

impl DetailsBuilder {
    /// Start building a new [`Details`] object.
    pub fn new(
        given_name: &amp;str,
        family_name: &amp;str,
        date_of_birth: time::Date,
    ) -&gt; Self {
        DetailsBuilder(Details {
            given_name: given_name.to_owned(),
            preferred_name: None,
            middle_name: None,
            family_name: family_name.to_owned(),
            mobile_phone: None,
            date_of_birth,
            last_seen: None,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>然后，构建者类型可以配备辅助方法来填充新项目的字段。每个这样的方法都会消耗 <code>self</code>，但会生成一个新的 <code>Self</code>，从而允许不同的构建方法进行链式调用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Set the preferred name.
pub fn preferred_name(mut self, preferred_name: &amp;str) -&gt; Self {
    self.0.preferred_name = Some(preferred_name.to_owned());
    self
}

/// Set the middle name.
pub fn middle_name(mut self, middle_name: &amp;str) -&gt; Self {
    self.0.middle_name = Some(middle_name.to_owned());
    self
}
<span class="boring">}</span></code></pre></pre>
<p>这些辅助方法可以比简单的设值器更加有用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Update the `last_seen` field to the current date/time.
pub fn just_seen(mut self) -&gt; Self {
    self.0.last_seen = Some(time::OffsetDateTime::now_utc());
    self
}
<span class="boring">}</span></code></pre></pre>
<p>构建者的最后一个方法会消耗构建者并生成构建好的项目：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Consume the builder object and return a fully built [`Details`]
/// object.
pub fn build(self) -&gt; Details {
    self.0
}
<span class="boring">}</span></code></pre></pre>
<p>总的来说，这让构建者的客户端拥有更符合人体工学的构建体验：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let also_bob = DetailsBuilder::new(
    "Robert",
    "Builder",
    time::Date::from_calendar_date(1998, time::Month::November, 28)
        .unwrap(),
)
.middle_name("the")
.preferred_name("Bob")
.just_seen()
.build();
<span class="boring">}</span></code></pre></pre>
<p>这种类型的构建者的全消耗特性导致了一些小问题。首先是无法单独分离出构建过程的各个阶段：</p>
<p>下面的例子是错误的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let builder = DetailsBuilder::new(
    "Robert",
    "Builder",
    time::Date::from_calendar_date(1998, time::Month::November, 28)
        .unwrap(),
);
if informal {
    builder.preferred_name("Bob");
}
let bob = builder.build();
<span class="boring">}</span></code></pre></pre>
<p>这段代码会产生如下错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error[E0382]: use of moved value: `builder`
   --&gt; src/main.rs:256:15
    |
247 |     let builder = DetailsBuilder::new(
    |         ------- move occurs because `builder` has type `DetailsBuilder`,
    |                 which does not implement the `Copy` trait
...
254 |         builder.preferred_name("Bob");
    |                 --------------------- `builder` moved due to this method
    |                                       call
255 |     }
256 |     let bob = builder.build();
    |               ^^^^^^^ value used here after move
    |
note: `DetailsBuilder::preferred_name` takes ownership of the receiver `self`,
      which moves `builder`
   --&gt; src/main.rs:60:35
    |
27  |     pub fn preferred_name(mut self, preferred_name: &amp;str) -&gt; Self {
    |                               ^^^^
<span class="boring">}</span></code></pre></pre>
<p>可以通过将被消耗的构建者重新分配给同一个变量来解决这个问题：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = DetailsBuilder::new(
    "Robert",
    "Builder",
    time::Date::from_calendar_date(1998, time::Month::November, 28)
        .unwrap(),
);
if informal {
    builder = builder.preferred_name("Bob");
}
let bob = builder.build();
<span class="boring">}</span></code></pre></pre>
<p>这种构建者的全消耗特性的另一个缺点是只能构建一个项目；尝试通过在同一个构建者上重复调用 <code>build()</code> 来创建多个实例，会如预期那样导致编译器报错：</p>
<p>下面的代码是有编译错误的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let smithy = DetailsBuilder::new(
    "Agent",
    "Smith",
    time::Date::from_calendar_date(1999, time::Month::June, 11).unwrap(),
);
let clones = vec![smithy.build(), smithy.build(), smithy.build()];
<span class="boring">}</span></code></pre></pre>
<pre><code class="language-shell">error[E0382]: use of moved value: `smithy`
   --&gt; src/main.rs:159:39
    |
154 |   let smithy = DetailsBuilder::new(
    |       ------ move occurs because `smithy` has type `base::DetailsBuilder`,
    |              which does not implement the `Copy` trait
...
159 |   let clones = vec![smithy.build(), smithy.build(), smithy.build()];
    |                            -------  ^^^^^^ value used here after move
    |                            |
    |                            `smithy` moved due to this method call
</code></pre>
<p>一种可选的方法是让构造器的方法接受<code>&amp;mut self</code>并输出一个<code>&amp;mut Self</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Update the `last_seen` field to the current date/time.
pub fn just_seen(&amp;mut self) -&gt; &amp;mut Self {
    self.0.last_seen = Some(time::OffsetDateTime::now_utc());
    self
}
<span class="boring">}</span></code></pre></pre>
<p>这样就不需要在各个构建阶段进行自我赋值了：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = DetailsBuilder::new(
    "Robert",
    "Builder",
    time::Date::from_calendar_date(1998, time::Month::November, 28)
        .unwrap(),
);
if informal {
    builder.preferred_name("Bob"); // no `builder = ...`
}
let bob = builder.build();
<span class="boring">}</span></code></pre></pre>
<p>然而，这个版本使得无法将构建者的构建与调用其设值方法链式结合在一起：</p>
<p>下面的代码是错误的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let builder = DetailsBuilder::new(
    "Robert",
    "Builder",
    time::Date::from_calendar_date(1998, time::Month::November, 28)
        .unwrap(),
)
.middle_name("the")
.just_seen();
let bob = builder.build();
<span class="boring">}</span></code></pre></pre>
<p>这段代码会产生如下错误：</p>
<pre><code class="language-shell">error[E0716]: temporary value dropped while borrowed
   --&gt; src/main.rs:265:19
    |
265 |       let builder = DetailsBuilder::new(
    |  ___________________^
266 | |         "Robert",
267 | |         "Builder",
268 | |         time::Date::from_calendar_date(1998, time::Month::November, 28)
269 | |             .unwrap(),
270 | |     )
    | |_____^ creates a temporary value which is freed while still in use
271 |       .middle_name("the")
272 |       .just_seen();
    |                   - temporary value is freed at the end of this statement
273 |       let bob = builder.build();
    |                 --------------- borrow later used here
    |
    = note: consider using a `let` binding to create a longer lived value
</code></pre>
<p>如编译器错误所示，可以通过给构建者项目命名来解决这个问题：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = DetailsBuilder::new(
    "Robert",
    "Builder",
    time::Date::from_calendar_date(1998, time::Month::November, 28)
        .unwrap(),
);
builder.middle_name("the").just_seen(); // 注意这行，是单独分离开来解决上面的编译错误的
if informal {
    builder.preferred_name("Bob");
}
let bob = builder.build();
<span class="boring">}</span></code></pre></pre>
<p>这种可变的构建者变体还允许构建多个项目。<code>build()</code> 方法的签名必须不消耗 <code>self</code>，因此必须如下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Construct a fully built [`Details`] object.
pub fn build(&amp;self) -&gt; Details {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>这个可重复的 <code>build()</code> 方法的实现必须在每次调用时构建一个新的项目。如果底层项目实现了 <code>Clone</code>，这很容易——构建者可以持有一个模板，并在每次构建时 <code>clone()</code> 它。如果底层项目没有实现 <code>Clone</code>，那么构建者需要有足够的状态，以便在每次调用 <code>build()</code> 时手动构建一个底层项目的实例。</p>
<p>无论使用哪种构建者模式，样例代码现在都集中在一个地方——构建者——而不是在每个使用底层类型的地方都需要。</p>
<p>剩余的样板代码可以通过使用宏（项目28）进一步减少，但如果你选择这种方法，你还应该检查是否有现成的 crate（特别是 <code>derive_builder</code> crate）可以提供所需的功能——前提是你愿意依赖它（项目25）。</p>
<p>译者注：构造器模式是一个非常常用的设计模式，在Rust中可以让一个对象的构建变得收敛且简单，也不用在对象内部字段变化的时候散弹式进行修改。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
